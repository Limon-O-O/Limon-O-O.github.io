<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cheatsheet | Limon's Blog]]></title>
  <link href="http://limon.top/blog/categories/cheatsheet/atom.xml" rel="self"/>
  <link href="http://limon.top/"/>
  <updated>2016-03-16T22:28:10+08:00</updated>
  <id>http://limon.top/</id>
  <author>
    <name><![CDATA[Limon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CheatSheet]]></title>
    <link href="http://limon.top/cheatsheet/"/>
    <updated>2015-12-23T04:22:06+08:00</updated>
    <id>http://limon.top/cheatsheet</id>
    <content type="html"><![CDATA[<h4>Swift 几种不错的遍历</h4>

<pre><code class="swift">
for i in 1...10 where i % 2 == 0 {
    print("\(i) is even")
}

for word in ["Lorem", "ipsum", "dolor", "sit", "amet", "consectetur",
    "adipiscing", "elit"] where word.characters.count &gt; 5 {
     print(word, "is a long word")
}


let items: [String?] = [nil, nil, "Hello", nil, "World"]
for case let item? in items {
    print(item)
}

let mySwitch = UISwitch()
let myView = UIView()
let myDate = NSDate()

let myItems: [NSObject] = [mySwitch, myDate, myView]
for case let item as UIView in myItems {
    print(item.frame)
}


protocol MyCustomProtocol {
    var frame: CGRect {get}
}

struct Bar {}
struct Foo: MyCustomProtocol {
    let frame: CGRect = .zero
}
extension UIView: MyCustomProtocol {}

let otherItems = [Bar(), Foo(), UIView()] as [Any]
for case let item as MyCustomProtocol in otherItems {
    print(item.frame)
}
</code></pre>

<p><br /></p>

<h4>字典合并</h4>

<pre><code>var parameters = [
    "page": "1",
    "offset": "20"
]

let params = ["type": "news"]

parameters.ifr_merge(params) // Output: ["offset": "20", "type": "news", "page": "1"]


extension Dictionary {

    mutating func ifr_merge&lt;K, V&gt;(dictionaries: Dictionary&lt;K, V&gt;...) {
        for dict in dictionaries {
            for (key, value) in dict {
                if let v = value as? Value, k = key as? Key {
                    self.updateValue(v, forKey: k)
                }
            }
        }
    }
}
</code></pre>

<p><br /></p>

<h4>优化 Cell 的使用体验</h4>

<pre><code>collectionView.registerNib(UINib(nibName: NewsCell.ifr_className, bundle: nil), forCellWithReuseIdentifier: NewsCell.ifr_className)
let cell = collectionView.dequeueReusableCellWithReuseIdentifier(NewsCell.ifr_className, forIndexPath: indexPath) as! NewsCell

extension UICollectionReusableView {
    static var ifr_className: String {
        return "\(self)"
    }
}
</code></pre>

<p><br /></p>

<h4>优化 ReloadData、Insert 的使用体验</h4>

<pre><code>var wayToUpdate: UICollectionView.WayToUpdate = .None
wayToUpdate = page == 1 ? .ReloadData : .Insert(indexPaths)
wayToUpdate.performWithCollectionView(self.collectionView)
</code></pre>

<pre><code>extension UICollectionView {

    enum WayToUpdate {

        case None
        case ReloadData
        case Insert([NSIndexPath])

        var needsLabor: Bool {

            switch self {
            case .None:
                return false
            case .ReloadData:
                return true
            case .Insert:
                return true
            }
        }

        func performWithCollectionView(collectionView: UICollectionView) {

            switch self {
                case .None:
                    break
                case .ReloadData:
                    collectionView.reloadData()
                case .Insert(let indexPaths):
                    collectionView.insertItemsAtIndexPaths(indexPaths)
            }
        }
    }
}
</code></pre>

<p><br /></p>

<h4>字体的适配</h4>

<pre><code>UIFont.ifr_adaptiveFont(.Regular(fontSize: 16.0)
</code></pre>

<pre><code>enum FontWeight {
    case Light(fontSize: CGFloat)
    case Regular(fontSize: CGFloat)
    case Medium(fontSize: CGFloat)
    case Bold(fontSize: CGFloat)
}

extension UIFont {

    class func ifr_adaptiveFont(weight: FontWeight) -&gt; UIFont {

        var weightString = ""
        var size: CGFloat = 16.0

        switch weight {

            case .Light(let fontSize):
                weightString = "-Light"
                size = fontSize

            case .Regular(let fontSize):
                weightString = ""
                size = fontSize

            case .Medium(let fontSize):
                weightString = "-Medium"
                size = fontSize

            case .Bold(let fontSize):
                weightString = "-Bold"
                size = fontSize
        }

        guard let systemFont = UIFont(name: "PingFangSC\(weightString)", size: size) ??
            UIFont(name: "STHeitiSC\(weightString)", size: size) else {
                return UIFont.systemFontOfSize(size)
        }

        return systemFont
    }
}
</code></pre>

<p><br /></p>

<h4>HTML 字符转义</h4>

<pre><code class="swift">var ifr_htmlEntityDecode: String {
    var text = stringByReplacingOccurrencesOfString("&amp;quot;", withString: "\"")
    text = text.stringByReplacingOccurrencesOfString("&amp;apos;", withString: "'")
    text = text.stringByReplacingOccurrencesOfString("&amp;lt;", withString: "&lt;")
    text = text.stringByReplacingOccurrencesOfString("&amp;gt;", withString: "&gt;")
    text = text.stringByReplacingOccurrencesOfString("&amp;amp;", withString: "&amp;")

    return text
}
</code></pre>

<p><br /></p>

<h4>repeat 一张小图片</h4>

<pre><code class="swift">
let patternImage = UIImage(named: "comment_bottomLine")
bottomImageView.image = nil
bottomImageView.backgroundColor = UIColor(patternImage: patternImage!)
</code></pre>

<p><br /></p>

<h4>NSURL 解析</h4>

<pre><code class="swift">
extension NSURL {
    var prt_URLItems: [String: String]? {

        let components = NSURLComponents(URL: self, resolvingAgainstBaseURL: false)

        guard let items = components?.queryItems else {
            return nil
        }

        var infos = [String: String]()
        items.forEach {
            infos[$0.name] = $0.value
        }
        return infos
    }
}
</code></pre>

<pre><code class="swift">
let items = NSURL(string: "http://www.weibo.com/1783821582/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo")?.prt_URLItems
print(items)

// Optional(["mod": "personinfo", "rightmod": "1", "wvr": "6"])
</code></pre>

<p><br /></p>

<h4>获取版本号和 Build 号</h4>

<pre><code>NSBundle.mainBundle().infoDictionary?["CFBundleVersion"] as? String // Build
NSBundle.mainBundle().infoDictionary?["CFBundleShortVersionString"] as? String // 版本号
</code></pre>

<p><br /></p>

<h4>判断一个 view 是否是另一个 view 的子视图</h4>

<pre><code class="swift">- (BOOL)isDescendantOfView:(UIView *)view;
</code></pre>

<p><br /></p>

<h4>隐藏或显示&#8221;隐藏文件&#8221;</h4>

<pre><code>defaults write com.apple.finder AppleShowAllFiles -boolean true; killall Finder
</code></pre>

<p><br /></p>

<h4>设置圆角（左上角，右上角）</h4>

<pre><code>UIBezierPath(roundedRect: ScreenBounds, byRoundingCorners: [.TopLeft, .TopRight], cornerRadii: CGSize(width: cornerRadius, height: 0.0))
</code></pre>

<p><br /></p>

<h4>阴影</h4>

<pre><code>whiteView.layer.shadowColor = UIColor.redColor().CGColor
whiteView.layer.shadowOffset = CGSizeMake(0, 1)
whiteView.layer.shadowOpacity = 1.0
whiteView.layer.shadowRadius = 20.0
whiteView.layer.shadowPath = UIBezierPath(rect: whiteView.bounds).CGPath
</code></pre>

<p><br /></p>

<h4>BasicAnimation</h4>

<pre><code>let pathAnimation = CABasicAnimation(keyPath: "path")
pathAnimation.fromValue = startPath
pathAnimation.toValue = endPath
pathAnimation.duration = 0.3
pathAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut) // animation curve is Ease Out
pathAnimation.fillMode = kCAFillModeBoth // keep to value after finishing
pathAnimation.removedOnCompletion = false // don't remove after finishing

shapeLayer.addAnimation(pathAnimation, forKey: pathAnimation.keyPath)
</code></pre>

<blockquote><p><a href="http://jamesonquave.com/blog/fun-with-cashapelayer/">Fun with CAShapeLayer</a></p></blockquote>

<p><br /></p>

<h4>禁止 <code>WKWebView</code> 长按复制</h4>

<pre><code>let source = "var style = document.createElement('style'); style.type = 'text/css'; style.innerText = '*:not(input):not(textarea) { -webkit-user-select: none; -webkit-touch-callout: none; }'; var head = document.getElementsByTagName('head')[0]; head.appendChild(style);";

let script: WKUserScript = WKUserScript(source: source as String, injectionTime: .AtDocumentEnd, forMainFrameOnly: true)

// Create the user content controller and add the script to it
let userContentController: WKUserContentController = WKUserContentController()
userContentController.addUserScript(script)

// Create the configuration with the user content controller
let configuration: WKWebViewConfiguration = WKWebViewConfiguration()
configuration.userContentController = userContentController
</code></pre>

<p><br /></p>

<h4>禁止 <code>WKWebView</code> 放大缩小</h4>

<pre><code>// Javascript that disables pinch-to-zoom by inserting the HTML viewport meta tag into &lt;head&gt;
let source: NSString = "var meta = document.createElement('meta');" +
    "meta.name = 'viewport';" +
    "meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';" +
    "var head = document.getElementsByTagName('head')[0];" +
"head.appendChild(meta);";

let script: WKUserScript = WKUserScript(source: source as String, injectionTime: .AtDocumentEnd, forMainFrameOnly: true)

// Create the user content controller and add the script to it
let userContentController: WKUserContentController = WKUserContentController()
userContentController.addUserScript(script)

// Create the configuration with the user content controller
let configuration: WKWebViewConfiguration = WKWebViewConfiguration()
configuration.userContentController = userContentController
</code></pre>

<p><br /></p>

<h4>根据触摸点判断是否 touch 点击了某个 view</h4>

<pre><code>override func touchesBegan(touches: Set&lt;NSObject&gt;, withEvent event: UIEvent) {
    super.touchesBegan(touches, withEvent: event)

    if let location = (touches.first as? UITouch)?.locationInView(self.view) {
        let searchCircleY = bottomView.frame.origin.y + searchCircleImageView.frame.origin.y
        let frame = CGRect(origin: CGPoint(x:searchCircleImageView.frame.origin.x, y:searchCircleY) , size: searchCircleImageView.size)
        if CGRectContainsPoint(frame, location) { // 点击在searchCircleImageView
            dismissViewControllerAnimated(true, completion: nil)
        }
    }
}
</code></pre>

<p><br /></p>

<h4>隐藏键盘(点击屏幕任意位置)</h4>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    [super touchesBegan:touches withEvent:event];
    [self.view endEditing:YES];
}
</code></pre>

<p><br /></p>

<p>在包含 <code>UITableView</code> 视图中添加单击手势
如果在包含 <code>UITableView</code> 视图中添加单击手势，这个单击手势会屏蔽掉 <code>UITableView</code>的 <code>-didSelectRowAtIndexPath</code></p>

<p>在单击点位于UITableView内的时候取消响应</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
    CGPoint point = [gestureRecognizer locationInView:self];
    if(CGRectContainsPoint(menuTableView.frame, point)){
        return NO;
    }
    return YES;
}
</code></pre>

<p>简单点的就将单击手势的 <code>cancelsTouchesInView</code> 设置为 NO 即可</p>

<pre><code class="swift">singleTap.cancelsTouchesInView = false
</code></pre>

<blockquote><p>默认为YES，若NO，Gesture Recognizers和hit-test view同时响应触摸序列</p></blockquote>

<p><br /></p>

<h4>Octopress</h4>

<pre><code>rake "new_post[Post Title]" // zsh下
rake generate                                  生成html文件
rake preview
rake deploy                                    部署文章（博客）
</code></pre>

<pre><code>git add .
git commit -m 'initial source commit'
git push origin source
</code></pre>

<p>deploy 时 <code>non-fast-forward</code> 问题解决方案</p>

<pre><code>cd octopress/_deploy
git pull origin master
cd ..
rake deploy
</code></pre>

<p><br /></p>
]]></content>
  </entry>
  
</feed>
