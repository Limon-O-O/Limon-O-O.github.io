<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: producter-tip | Limon's Blog]]></title>
  <link href="limon.top/blog/categories/producter-tip/atom.xml" rel="self"/>
  <link href="limon.top/"/>
  <updated>2016-01-01T02:31:14+08:00</updated>
  <id>limon.top/</id>
  <author>
    <name><![CDATA[Limon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Matching Option]]></title>
    <link href="limon.top/blog/2015/12/23/matching-option/"/>
    <updated>2015-12-23T22:36:43+08:00</updated>
    <id>limon.top/blog/2015/12/23/matching-option</id>
    <content type="html"><![CDATA[<pre><code>{
    "articles": [
        {
            "type": "app", // AppSo文章
            "cellHeight": "100"
        },
        {
            "type": "number", // 数独文章
            "cellHeight": "200"
        },
        {
            "type": "mindStore", // MindStore文章
            "cellHeight": "300"
        }
    ]
}
</code></pre>

<p>假设服务器返回以上的JSON，客户端需要根据文章类型来作不同的布局。</p>

<p>第一时间可能会想到以下的方法来switch：</p>

<pre><code class="Swift">let typeString = "app"
switch typeString {

  case "app":
    print("AppSo Article")

  case "number":
    print("Number Article")

  default:
    break
}
</code></pre>

<p><br /></p>

<p>较为优雅的方法是用<code>enum</code>来管理类型：</p>

<pre><code>enum Occupation: String {
  case AppSo = "app"
  case Number = "number"
}

let typeString = "mindStore"

switch Occupation(rawValue: typeString) {

  case .AppSo?:
    print("AppSo Article")

  case .Number?:
    print("Number Article")

  case nil:
    print("Article?")
}
</code></pre>

<p><br /></p>

<p>抽取于：<a href="http://www.figure.ink/blog/2015/12/6/matching-with-swifts-optional-pattern?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=web&amp;utm_source=This_Week_in_Swift_65">Matching with Swift&rsquo;s Optional Pattern</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优雅地自定义XibView]]></title>
    <link href="limon.top/blog/2015/12/23/customxibview/"/>
    <updated>2015-12-23T21:38:17+08:00</updated>
    <id>limon.top/blog/2015/12/23/customxibview</id>
    <content type="html"><![CDATA[<h2>优雅地自定义XibView</h2>

<p>好习惯，先上<a href="https://github.com/Limon-catch/XibView">源码</a>。</p>

<p>先创建一个UIView文件和一个Xib文件，在Xib文件里设置如下，</p>

<p><img src="https://raw.githubusercontent.com/Limon-catch/XibView/master/XibView/Image/XibView_Step1.png" alt="" /></p>

<p>在UIView文件中，不是用<code>-awakeFromNib()</code>作为构造器，而是正常的<code>-init(frame: CGRect)</code>。</p>

<pre><code class="swift">
override init(frame: CGRect) {
    super.init(frame: frame)

    xibSetup()
}
</code></pre>

<p>而<code>-xibSetup()</code>才是关键，具体可看源码。</p>

<p><br />
如果需要UIView和Xib文件建立控件属性关联，是设置Xib文件的File`s Owner，<strong><em>而不是设置View的Custom Class</em></strong>。</p>

<p><img src="https://raw.githubusercontent.com/Limon-catch/XibView/master/XibView/Image/XibView_Step2.png" alt="" /></p>

<p>设置了File`s Owner就可以像往常一样拖线了。</p>

<p>如果想在<code>Main.storyboard</code>文件中直接使用此Xib，同时也想在SB中设置属性，那怎么使用呢？</p>

<ol>
<li>在SB中加入一个UIView，将其Class设置成<code>XibView</code><br /></li>
<li>使用<code>@IBInspectable</code></li>
</ol>


<pre><code>@IBInspectable var title: String? {
    get {
        return xibLabel.text
    }
    set {
        xibLabel.text = newValue
    }
}
</code></pre>

<p><br />
添加了<code>@IBInspectable</code>之后，就可以像系统自带的控件一样设置属性了。</p>

<p><img src="https://raw.githubusercontent.com/Limon-catch/XibView/master/XibView/Image/XibView_Step3.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
