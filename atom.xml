<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Limon's Blog]]></title>
  <link href="http://limon.top/atom.xml" rel="self"/>
  <link href="http://limon.top/"/>
  <updated>2017-03-15T00:03:47+08:00</updated>
  <id>http://limon.top/</id>
  <author>
    <name><![CDATA[Limon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一个仓库的模块化之路]]></title>
    <link href="http://limon.top/mediator/"/>
    <updated>2017-02-13T20:12:43+08:00</updated>
    <id>http://limon.top/mediator</id>
    <content type="html"><![CDATA[<h1>一个仓库的模块化之路</h1>

<p>本文对应的 GitHub 项目 <a href="https://github.com/Limon-O-O/Lego">Lego</a>，不定期更新实践感悟。</p>

<p>本文讲解的是如何在一个仓库进行模块化，当然，如果你想拆分一个模块对应一个仓库，也行，改改就是了。</p>

<p>建议先仔细阅读 Mr.Casa 的<a href="http://casatwy.com/modulization_in_action.html">《在现有工程中实施基于CTMediator的组件化方案》</a>，本文魔改于此。</p>

<p>本文要点：</p>

<ol>
<li>Swift 项目怎样使用 Mediator 进行模块化</li>
<li>使用 CocoaPods 管理模块</li>
<li>一键创建模块（包括 Xcode 工程），一键发布 <code>Pod库</code></li>
<li>发布私有库不使用 <code>pod repo push</code>，不进行验证，即使库编译不通过，也可以 release 新版本</li>
<li>Swift 的一些实践心得</li>
</ol>


<p>本文分为三部分：</p>

<p>一、<a href="https://github.com/Limon-O-O/Lego#%E4%B8%80lego-%E7%9B%AE%E5%BD%95%E8%A7%A3%E6%9E%90">目录解析</a></p>

<p>二、<a href="https://github.com/Limon-O-O/Lego#%E4%BA%8C%E5%AE%9E%E6%88%98">实战</a></p>

<p>三、<a href="https://github.com/Limon-O-O/Lego#%E4%B8%89%E5%AE%9E%E8%B7%B5%E5%BF%83%E5%BE%97">实践心得</a></p>

<p><br /></p>

<h2>一、Lego 目录解析</h2>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>Lego
</span><span class='line'>├── ConfigPrivatePod
</span><span class='line'>├── Frameworks
</span><span class='line'>│   ├── EggKit
</span><span class='line'>│   ├── LegoKit
</span><span class='line'>│   └── Networking
</span><span class='line'>├── Modules
</span><span class='line'>│   ├── CTMediator+Door
</span><span class='line'>│   ├── Door
</span><span class='line'>│   ├── Lego
</span><span class='line'>└── Specs
</span><span class='line'>    ├── EggKit
</span><span class='line'>    ├── LegoKit
</span><span class='line'>    └── Networking
</span><span class='line'>        └── 1.0.1
</span><span class='line'>            └── Networking.podspec</span></code></pre></td></tr></table></div></figure>


<ol>
<li><code>ConfigPrivatePod</code> 文件夹，存放着配置私有模块的脚本</li>
<li><code>Frameworks</code> 文件夹，存放着各种 <code>framework</code>，<code>EggKit</code> 代表公司各项目通用库，<code>LegoKit</code> 代表本项目各模块通用库</li>
<li><code>Modules</code> 文件夹，存放着 <code>Lego</code> 项目的全部模块，其中 <code>Modules/Lego</code> 就是主模块</li>
<li><code>Specs</code> 文件夹，存放着 <code>framework</code> 和 <code>模块</code> 的版本的 <code>podName.podspec</code>，即常说的 <code>Private Spec Repo</code></li>
</ol>


<p><br /></p>

<h2>Config PrivatePod</h2>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>ConfigPrivatePod
</span><span class='line'>├── config.sh
</span><span class='line'>└── pod-template
</span><span class='line'>└── templates
</span><span class='line'>    ├── Podfile
</span><span class='line'>    ├── module
</span><span class='line'>    │   ├── extension
</span><span class='line'>    │   │   ├── Mediator+Project.swift
</span><span class='line'>    │   │   └── ProjectProtocol.swift
</span><span class='line'>    │   └── target
</span><span class='line'>    │       └── Target_Project.swift
</span><span class='line'>    ├── pod.podspec
</span><span class='line'>    ├── release.sh
</span><span class='line'>    ├── update_version.sh
</span><span class='line'>    └── version_compare.sh</span></code></pre></td></tr></table></div></figure>


<p><code>ConfigPrivatePod</code> 文件夹内含快速配置私有模块的脚本</p>

<p><code>config.sh</code> 新创建 <code>Pod库</code> 时使用，作用：</p>

<ol>
<li>创建 Xcode 工程（注：原理和 <code>pod lib create NAME</code> 一致）</li>
<li>为 <code>Pod库</code> 配置基本文件，如 <code>pod.podspec</code></li>
<li>配置 <code>release.sh</code> 脚步，需要为 <code>Pod库</code> 发布新版本时，直接敲命令 <code>./release.sh</code> 即可</li>
<li>为模块配置与 <code>Mediator</code> 关联的文件，如：<code>Target_Project.swift</code>, <code>ProjectProtocol.swift</code>, <code>Mediator+Project.swift</code></li>
</ol>


<p><br /></p>

<h2>关于 CocoaPods Specs</h2>

<p>大家都知道 CocoaPods 可以指定第三方依赖的版本，比如：<code>pod 'MonkeyKing', '~&gt; 1.2.1'</code></p>

<p>那 CocoaPods 是如何管理所有已经发布了的版本？
答案就在此 <a href="https://github.com/CocoaPods/Specs">CocoaPods Specs</a> 仓库。Specs 仓库里面存放着所有已经发布了的版本。</p>

<p>比如 MonkeyKing 的已发布的版本 <a href="https://github.com/CocoaPods/Specs/tree/master/Specs/f/6/5/MonkeyKing">Specs</a>，在此 <a href="https://github.com/CocoaPods/Specs/tree/master/Specs/f/6/5/MonkeyKing">Specs</a> 里面，列举 MonkeyKing 所有已经 released 的版本。</p>

<p>MonkeyKing 在 <code>Specs</code> 文件夹的呈现：</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>└── Specs
</span><span class='line'>    └── MonkeyKing
</span><span class='line'>        └── 0.0.1
</span><span class='line'>            └── MonkeyKing.podspec.json
</span><span class='line'>        .......
</span><span class='line'>            
</span><span class='line'>        └── 0.9.3
</span><span class='line'>            └── MonkeyKing.podspec.json
</span><span class='line'>        └── 1.1.0
</span><span class='line'>            └── MonkeyKing.podspec.json
</span><span class='line'>        └── 1.2.0
</span><span class='line'>            └── MonkeyKing.podspec.json
</span><span class='line'>        └── 1.2.1
</span><span class='line'>            └── MonkeyKing.podspec.json
</span><span class='line'>        └── 1.2.2
</span><span class='line'>            └── MonkeyKing.podspec.json</span></code></pre></td></tr></table></div></figure>


<p><code>https://github.com/CocoaPods/Specs.git</code> 是 CocoaPods 官方的 <code>Specs</code> 仓库，平时我们用 <code>pod trunk push podName.podspec</code> 来发布新版本，其实就是向此仓库添加一个名为 <code>podName.podspec</code> 的文件。</p>

<p><a href="https://github.com/CocoaPods/Specs">CocoaPods Specs</a> 是线上版，在我们本地，其实也有这个仓库，执行下面的命令就可以看到，其中 <code>master</code> 对应 CocoaPods 官方的 <code>Specs</code> 仓库。</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>cd ~/.cocoapods/repos && ls</span></code></pre></td></tr></table></div></figure>


<p>而在此教程的 <code>Lego</code> 仓库里，有一个文件夹 <a href="https://github.com/Limon-O-O/Lego/tree/master/Specs">Specs</a>，此文件夹里存放着 <code>framework</code> 和模块 Pod 的 <code>podspec</code>，相当于 Private Spec Repo</p>

<blockquote><p>更多详情请查看官方资料：<a href="https://guides.cocoapods.org/making/private-cocoapods.html">Private Pods</a></p></blockquote>

<p><br /></p>

<h2>二、实战</h2>

<h3>实战前夕</h3>

<ol>
<li><p>新建一个仓库，就先名为 <code>Lego</code>，页面先不急着关，打开 <code>Terminal</code></p></li>
<li><p><code>pod repo add [私有Pod源仓库名字] [私有Pod源的repo地址]</code>，添加私有源到本地</p></li>
<li><p>把刚刚新建的仓库 <code>clone</code> 到本地，把 <a href="https://github.com/Limon-O-O/Lego/tree/master/ConfigPrivatePod">ConfigPrivatePod</a> 文件夹放进去</p></li>
<li><p>在 <code>./ConfigPrivatePod/config.sh</code> 文件里，填写 <code>httpsRepo</code>, <code>sshRepo</code>, <code>specsRepo</code>, <code>homePage</code>, <code>author</code>, <code>email</code>，<a href="https://github.com/Limon-O-O/Lego/blob/master/ConfigPrivatePod/config.sh#L3">具体参考</a></p>

<blockquote><p>当然，在这里填写这4个默认参数的前提是，想把全部模块都放在同一个 <code>仓库</code> 里面，如果打算一个模块一个 <code>仓库</code>，请参考 Mr.Casa 的<a href="http://casatwy.com/modulization_in_action.html">《在现有工程中实施基于CTMediator的组件化方案》</a></p></blockquote></li>
<li><p>新建三个文件夹 <code>Frameworks</code> <code>Modules</code> <code>Specs</code>，最终的结构如下：</p></li>
</ol>


<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>Lego
</span><span class='line'>├── ConfigPrivatePod
</span><span class='line'>│   ├── config.sh
</span><span class='line'>│   └── templates
</span><span class='line'>│   └── pod-template
</span><span class='line'>│       ......
</span><span class='line'>├── Frameworks
</span><span class='line'>├── Modules
</span><span class='line'>└── Specs</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<h3>新建主模块和 Door 模块</h3>

<h5>主模块 &mdash; Lego</h5>

<p>使用 Xcode 创建一个名为 <code>Lego</code> 的工程，放在 <code>Lego/Modules</code> 下，此工程就是我们的主模块。</p>

<h5>Door 模块</h5>

<p>若想新建一个 Door 模块，需要两个 <code>Pod库</code>，
1. Door业务Pod
2. 方便其它模块调用 Door业务 的 Mediator+Door 的 Pod。</p>

<blockquote><p>这里多解释一句：Mediator+Door Pod 本质上只是一个方便方法，它对 Door Pod 不存在任何依赖</p></blockquote>

<p>开始创建：</p>

<ol>
<li>同创建主模块一样，创建一个名为 <code>Door</code> 的工程，放在 <code>Lego/Modules</code> 下，此模块主打<code>注册登录</code>。</li>
<li>再创建一个名为 <code>Mediator+Door</code> 的工程，同样放在 <code>Lego/Modules</code> 下，此工程主要为了方便其它模块调用 Door业务，本质就是通过 <code>Mediator</code> 利用<code>运行时</code>，找到在 <code>Door</code> 内相对应的方法。</li>
<li><p>在 <code>ConfigPrivatePod</code> 下，执行 <code>./config.sh</code>，脚本会问你要一些信息。</p>

<p> 配置 <code>Door</code> 工程：</p>

<pre><code class="`"> Enter Project Name: Door

 ================================================
  1 :  Module
 2 :  Extension
 3 :  Framework
 ================================================

 Enter Project Type Number: 1
</code></pre>

<p> 配置 <code>Mediator+Door</code> 工程：</p>

<pre><code class="`"> Enter Project Name: Door // 注：Project Name 也是 Door

 ================================================
 1 :  Module
 2 :  Extension
 3 :  Framework
 ================================================

 Enter Project Type Number: 2
</code></pre>

<blockquote><p>若配置模块工程，<code>Project Type Number</code> 输入 <code>1</code>，若配置 <code>模块Extension</code> 工程，输入 <code>2</code>，若配置普通的 <code>framework</code> 输入 <code>3</code></p></blockquote>

<p> 配置完 <code>Door</code> 工程后，在 <code>Modules/Door/Door</code> 下，会多了一个也同样名为 <code>Door</code> 的文件夹，以后所有需要打包出去给别人用的都在此文件夹下，因为在 <code>Door.podspec</code> 文件内定义的源文件就指指定了此文件夹。</p></li>
<li><p>打开 <code>Door.xcodeproj</code>，把 <code>Modules/Door/Door/Door</code> 此文件夹工程里面。 <code>Mediator+Door</code> 工程同理。</p>

<p> <code>Door</code> 工程的目录简如下：</p>

<pre><code class="`"> Door
 ├── Door
 │   └── Door
 │       ├── WelcomeViewController.swift
 │       └── Targets
 │           ├── Target_Door.swift
 ├── Door.xcodeproj
</code></pre>

<p> <code>Mediator+Door</code> 工程的目录简如下：</p>

<pre><code class="`"> Mediator+Door
 ├── Mediator+Door
 │   └── Mediator+Door
 │       ├── Door.swift
 │       ├── Mediator+Door.swift
 ├── Mediator+Door.xcodeproj
</code></pre></li>
</ol>


<p>到此，<code>Door模块</code> 基本配置完成，可以前往 <code>主模块Lego</code> 引入它了。</p>

<p><br /></p>

<h3>在主模块使用 Door 模块</h3>

<h5>在主模块引入 Door 模块</h5>

<p><code>Modules/Lego/Podfile</code>:</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>source 'https://github.com/Limon-O-O/Lego.git' # 这是 Specs 仓库的地址，在本文中，和项目的仓库地址一致
</span><span class='line'>source 'https://github.com/CocoaPods/Specs.git'
</span><span class='line'>platform :ios, '9.0'
</span><span class='line'>
</span><span class='line'>target 'Lego' do
</span><span class='line'>    use_frameworks!
</span><span class='line'>
</span><span class='line'>    # Door，在开发初期，先用相对路径，因为现在 CocoaPods 支持跨工程修改，便于开发
</span><span class='line'>    pod "Mediator+Door", :path =&gt; "../Mediator+Door"
</span><span class='line'>    pod "Door", :path =&gt; "../Door"
</span><span class='line'>    
</span><span class='line'>    # Me，若模块已经开发得差不多了，并 released 了，可从 Private Spec 拉取
</span><span class='line'>    pod "Mediator+Me"
</span><span class='line'>    pod "Me", '~&gt; 1.0.1'
</span><span class='line'>end
</span></code></pre></td></tr></table></div></figure>


<h3>发布 Door 模块</h3>

<p>在 <code>Modules/Door</code> 下，敲命令 <code>./release.sh</code>，脚本会问你需要发布的版本号，仅需要输入一个版本号，其它的脚本都帮你做好了。</p>

<p>发布成功之后，还需要更新 <code>Private Spec</code>，命令：<code>pod repo update [Name]</code>，这个 <code>[Name]</code> 就是 <code>私有Pod源的名字</code>，在上面我们用命令 <code>pod repo add [私有Pod源仓库名字] [私有Pod源的repo地址]</code> 添加了的。也可以 <code>cd ~/.cocoapods/repos &amp;&amp; ls</code> 查看</p>

<p><code>release.sh</code> 主要作用有：</p>

<ol>
<li>更新 <code>Door.podspec</code></li>
<li>更新 <code>README.md</code></li>
<li>更新 <code>Info.plist</code> 的版本号</li>
<li>复制一份 <code>Door.podspec</code> 到 <code>Specs</code> 文件夹</li>
<li><code>git push</code> 相关变动到远程仓库</li>
</ol>


<p><br /></p>

<h2>三、实践心得</h2>

<ol>
<li><p><code>Networking</code>，分模块。各个模块的 API，分别写到相对应的模块，没有一个 <code>集约型</code> 的文件。</p></li>
<li><p><code>UserDefaults</code> 分模块，也稍微避免 <code>UserDefaults.standard</code> 存储大量数据之后，导致读写慢</p>

<pre><code class="`"> UserDefaults(suiteName: "top.limon.door")
 UserDefaults(suiteName: "top.limon.lego")
</code></pre>

<p> 如果模块之间需要传递 <code>UserDefaults</code> 的值，通过 <code>Mediator</code> 调度，不直接公开 <code>UserDefaults</code>。</p></li>
<li><p>通过 <code>Mediator</code> 传递的 <code>Data</code> 必须是 <code>NSObject</code>，不然崩溃</p>

<pre><code class="`"> extension Target_Door {

     func Action_DidLogin() -&gt; [String: Any] {
         return ["result": DoorUserDefaults.didLogin]
     }

     func Action_DidLogin() -&gt; Bool { // Bool 不是 NSObject，崩溃
         return true
     }
 }
</code></pre>

<p> 然并卵，<code>[String: Any]</code> 理论上是 <code>AnyObject</code>，但却不崩溃，难道自动转成了 <code>NSDictionary</code> ？</p>

<p> 如果返回 <code>Bool</code>，崩溃信息：<code>unrecognized selector sent to instance</code>，若想更深入探讨，可运行 <a href="https://github.com/Limon-O-O/Mediator">God项目</a> 进行测试</p></li>
<li><p>使用 <code>Mediator</code> 进行模块化，避免不了<code>Hard Code</code>，特别是在模块之间的通讯时，建议 <code>Hard Code</code> 尽量写在 <code>Extension</code> 内，比如 <code>Mediator+Door.swift</code> 的 <code>deliverParams</code> 的 <code>navigationBarHidden</code>, <code>callbackAction</code></p>

<pre><code class="`"> extension Door where Base: Mediator {

     public func welcomeViewController(_ navigationBarHidden: Bool = true, _ callbackAction: @escaping (([String: Any]) -&gt; Void)) -&gt; UIViewController? {
         let deliverParams: [String: Any] = ["navigationBarHidden": navigationBarHidden, "callbackAction": callbackAction]
         return base.performTarget("Door", action: "WelcomeViewController", params: deliverParams) as? UIViewController
     }
 }
</code></pre></li>
<li><p>使用 <code>Storyboard Reference</code> 连接其它模块的 <code>Storyboard</code>，注意 <code>Bundle</code> 的填写</p>

<p> <img src="https://ww4.sinaimg.cn/large/006tNbRwly1fd7jvecf8cj30e805mq3g.jpg" width="420"></p></li>
<li><p>使用 <code>Protocol</code> + <code>Extension</code> 更好地区分作用域，<code>Mediator.shared.door.accessToken()</code>，其中的 <code>door</code> 是不是挺好看的 🌝，而不是 <code>Mediator.shared.door_accessToken()</code></p></li>
<li><p>关于脚本创建 Xcode 工程，使用的是 <code>CocoaPods</code> 的 <a href="https://github.com/CocoaPods/pod-template">pod-template</a>，另外也可以使用 <a href="https://github.com/CocoaPods/Xcodeproj">Xcodeproj</a> 或 <a href="https://github.com/thoughtbot/liftoff">liftoff</a></p>

<blockquote><p>注：平时用 <code>pod lib create NAME</code> 创建 <code>pod</code>，就是拉取 <a href="https://github.com/CocoaPods/pod-template">pod-template</a> 来创建 Xcode 工程</p></blockquote>

<pre><code class="`"> pod lib create TestPod 
 Cloning `https://github.com/CocoaPods/pod-template.git` into `TestPod`.
 Configuring TestPod template.
</code></pre></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数字媒体(内部分享)]]></title>
    <link href="http://limon.top/media/"/>
    <updated>2017-01-16T00:32:32+08:00</updated>
    <id>http://limon.top/media</id>
    <content type="html"><![CDATA[<h2>了解数字媒体</h2>

<p>数字媒体是指以二进制数的形式记录、处理、传播、获取过程的信息载体，这些载体包括数字化的文字、图形、图像、声音、视频影像和动画等。使用数字媒体已经成为广大用户一种本能的习惯，但你是否想过这些媒体内容被数字化的呢？</p>

<p>我们看到的信号标志和所听到的音乐都是通过模拟信号传递给我们的，我们的研究和耳朵构成将这些信息转换为我们大脑能解析出来的电信号。</p>

<p>现实生活中的信号是连续的，信号的频率和强度是在不断变化的，但是数字世界的信号是离散的，由 1 和 0 两个状态表示，要将模式信号转换成能存储传输的数字信号，要经过模拟-数字转换过程，这一过程称为<strong>采样(Smapling)</strong></p>

<h2>数字媒体采样</h2>

<p>对媒体内容进行数字化主要有两种方式：</p>

<h6>时间采样</h6>

<p>时间采样方法捕捉一个信号周期内的变化。比如当记录一个音频，在录制期间所有的音高变化和声调变化都会被捕捉下来。</p>

<h6>空间采样</h6>

<p>空间采样一般都用在图片数字化和其他可视化媒体内容数字化的过程中。空间采样包含对一副图片在一定分辨率之下捕捉其亮度和色度，进而创建由该图片的像素点数据所构成的数字化结果。</p>

<h2>音频采样介绍</h2>

<p>想象一下，当你拨动琴弦的时候，可以直观地看到信号的频率和振幅。这个振动会导致周围的空气分子移动，这些分子会依次同其临近的空气分子进行碰撞，之后再依次传递这个碰撞，将最初的振动能量不断地向各个方向进行传播。当这些波动传到接受者的耳中时，会带动耳膜以同样的频率和振幅振动。这些振动继续传递到内耳的耳蜗上，此时会将这些振动转换成电信号传给大脑，大脑会处理这个信号并知道“我听到了一个 G 声调”。</p>

<p>当我们记录一个声音时，一般会使用麦克风设备。麦克风是将机械能量(声波)转换成电能量(电压信号)的转换设备。这里讨论下电动式麦克风(dynamic microphone)。图 1 展示了电动式麦克风内部的高级视图。</p>

<p><img src="http://ww2.sinaimg.cn/large/006tNbRwjw1f5jfgz937hj312a0gmmyj.jpg" width="600"></p>

<p>在麦克风的头部设备中所包含的，作为接收声音的一部分，是薄薄的被称为&#8221;膜片&#8221;的薄膜。这个膜片连接缠绕着磁极的线圈，当你对着麦克风讲话时，膜片会根据其感受到的声波进行振动，再依次带动线圈振动，产生同输入信号相同频率和振幅的电流信号。使用示波器我们可以看到电信号的振荡，如图 2 所示：</p>

<p><img src="http://ww1.sinaimg.cn/large/006tNbRwjw1f5jflubgm6j314s0moac1.jpg" width="600"></p>

<p>回归音频采样的主题，我们应该如何将这个连续的信号转换成相应的离散形式呢，即使用音频生成器，这里我们创建了两个不同的音频正弦波，如图 3 所示。</p>

<p><img src="http://ww1.sinaimg.cn/large/006tNbRwjw1f5jfsn0jufj31ie0pyn14.jpg" width="600"></p>

<p>我们对这个信号的两个方面比较感兴趣。</p>

<ul>
<li>振幅</li>
<li>频率</li>
</ul>


<p>振幅，它代表了电压的强度或相应信号的强度。虽然可以通过不同坐标系来呈现正弦曲线的变化，但是通常我们会选择-1.0f到1.0f作为坐标系的最大值和最小值。</p>

<p>频率，信号频率的测量单位是赫兹(Hz)，表示在一定周期内振动完成循环的次数。图 3 左边的图片展示了 1Hz 情况下音频信号的一个周期，右边的图片展示了 5Hz 情况下的信号情况。人类可以听到的音频范围是20Hz～20kHz(20 000Hz)。</p>

<p><br/></p>

<h4>线性脉冲编码调制</h4>

<p>音频数字化的过程包含一个编码方法，称为<strong>线性脉冲编码调制</strong>(linear pulse-code modulation)，比较常见的说法是Linear PCM或LPCM。线性脉冲编码调制是对连续变化的模拟信号进行抽样、量化和编码产生的数字信号。LPCM的优点就是音质好，缺点就是体积大。</p>

<p>这个过程采样或测量一个固定的音频信号，过程的周期率被称为<strong>采样率</strong>。图 4 展示了在一秒内对信号进行 7 次采样及信号的数字化结果图。</p>

<p><img src="http://ww2.sinaimg.cn/large/006tNbRwjw1f5jg1su2dfj31j60midi4.jpg" width="600"></p>

<p>显然低采样率的数字信号版本无法很好地表现原始数据。我们按图 5 所示的情况再做一次，这次我们提高采样频率。</p>

<p><img src="http://ww2.sinaimg.cn/large/72f96cbajw1f5lrg6drzgj21k20lsjti.jpg" width="600"></p>

<p>这次效果显然得到提升，但仍不能准确表示原始信号。
不过通过这个示例你可以推测，如果不断提高采样的频率，我们就有可能以数字化方式准确表现原始信号的信息。那我们能否找到一个采样频率用于生成足够好的数字呈现效果？答案是肯定的。</p>

<p>20世纪30年代，Harry Nyquist 是贝尔实验室的一名工程师，他精确地捕捉到了一个特定频率，该频率为需要采样对象的最高频率的两倍。
我们称其为<strong>尼奎斯特频率(Nyquist rate)</strong> 。</p>

<p>比如一个你需要捕捉的音频素材的最高频率为10kHz，你所需要的采样率最起码为20kHz才能得到较好的数字化效果。</p>

<p>除采样率外，数字音频采样的另一个重要方面是我们能够捕捉到什么精度的音频样本，那就是音频的位元深。<strong>音频的位元深</strong> 用于保存样本值的字节数定义了在线性维度上可行的离散度。使用位元深度为8的方法可以提供256个离散级别的数据，对于一些音频资源来说，这个级别的采样率已经足够了，但对于大部分音频内容来说还不够高。CD音质的位元深度为16，可以达到65 536个离散级别。专业级别的音频录制环境的位元深度可以达到24或更高。</p>

<p><br/></p>

<h2>数字媒体压缩</h2>

<h4>音频压缩</h4>

<p>音频信号压缩编码的主要依据是人耳的听觉特性，主要有两点：</p>

<ul>
<li>人的听觉系统中存在一个听觉阈值电平，低于这个电平的声音信号人耳听不到。</li>
<li>人的听觉存在 屏蔽效应。当几个强弱不同的声音同时存在时，强声使弱声难以听到，并且两者之间的关系与其相对频率的大小有关。</li>
</ul>


<p>声音编码算法就是通过这些特性来去掉更多的冗余数据来达到压缩数据的目的。
音频信号数字化后经过压缩编码，形成下列主要格式的文件：</p>

<h5>WAV(.wav)</h5>

<p>WAV 文件又称波形文件，来源于对声音模拟波形的采样，并以不同的量化位数把这些采样点的值轮换成二进制数，然后存入磁盘，这就产生了波形文件。 WAV 文件用于保存 Windows 平台的音频信息资源，被 Windows 平台及其应用程序所广泛支持。</p>

<p>特点：声音再现容易，占用存储空间大，用Windows播放器播放</p>

<h5>MP3</h5>

<p>MP3的全名是MPEG Audio Layer-3。
ISO/MPEG 音频压缩标准里包括了三个使用高性能音频数据压缩方法的感知编码方案， 按照压缩质量(每Bit的声音效果)和编码方案的复杂程度分别是 Layer1、Layer2、Layer3，同时也分别对应 .mp1、.mp2、.mp3 的文件格式。所有这三层的编码采用的基本结构是相同的。它们在采用传统的频谱分析和编码技术的基础上还应用了子带分析和心理声学模型理论。也就是通过研究人耳和大脑听觉神经对音频失真的敏感度，在编码时先分析声音文件的波形，利用滤波器找出噪音电平(Noise Level)，然后滤去人耳不敏感的信号，通过矩阵量化的方式将余下的数据每一位打散排列，最后编码形成MPEG的文件。而音质听起来与CD相差不大。</p>

<h5>MP4</h5>

<p>MP4 并不是 MPEG-4 或者 MPEG Audio Layer-3，它的出现是针对MP3的大众化、无版权的一种保护格式，由美国网络技术公司开发，美国唱片行业联合会倡导公布的一种新的网络下载和音乐播放格式。</p>

<p>MP4 使用的是 MPEG-2 AAC技术也就是俗称的 a2b 或 AAC(Advanced Audio Coding(先进音频编码))。</p>

<p>MP4 技术的优越性要远远高于MP3，因为它更适合多媒体技术的发展以及视听欣赏的需求。但是，MP4是一种商品，它利用改良后的MPEG-2 AAC技术并强加上由出版公司直接授权的知识产权协议作为新的标准；而MP3是一种自由音乐格式，任何人都可以自由使用。此外，MP4 实际上是由音乐出版界联合授意的官方标准；MP3 则是广为流传的民间标准。</p>

<p><br /></p>

<h4>视频压缩</h4>

<h5>色彩二次抽样</h5>

<p>视频数据是使用称之为Y&#8217;CbCr′ 颜色模式的典型案例，Y&#8217;CbCr′ 也常称为YUV。虽然YUV术语并不很准确，但是 YUV 读起来要比Y-Prime-C-B-C-R 方便很多。YUV 将亮度信息（Y）与色彩信息（UV）分离，没有 UV 信息一样可以显示完整的图像，只不过是黑白的（这个设计很好地解决了彩色电视机与黑白电视的兼容问题）。</p>

<p>YUV 不像 RGB 那样要求三个独立的视频信号同时传输，所以用 YUV 方式传送占用极少的频宽。</p>

<p>图 6、图 7 展示了一幅图片分离亮度和色彩通道后的效果。</p>

<p><img src="http://ww2.sinaimg.cn/large/72f96cbajw1f5lsjb0zlaj20vg09s413.jpg" width="600"></p>

<p><img src="http://ww2.sinaimg.cn/large/72f96cbajw1f5miuaijg1j205k0gm3zt.jpg" width="260"></p>

<p>可以看到图片的所有细节都保存在亮度通道中，如果除去亮度，剩下的就是一幅灰度图片，我们再看整合的色彩通道中几乎所有的细节都丢失了。这是因为我们的眼睛对亮度的敏感度要高于颜色，聪明的工程师们认识到，我们可以大幅减少存储在每个像素中的颜色信息，而不至于图片的质量严重受损。这个减少颜色数据的过程就称为<strong>色彩二次抽样</strong>。</p>

<p>当每次看到诸如摄像头规范和其他视频设备硬件或软件中提到的4:4:4、4:2:2 及 4:2:0 时，这些值的含义就是这些设备所使用的色彩二次抽样的参数（YUV 采样方式）。</p>

<p>当每次看到诸如摄像头规范和其他视频设备硬件或软件中提到的4:4:4、4:2:2及4:2:0时，这些值的含义就是这些设备所使用的色彩二次抽样的参数</p>

<ul>
<li>YUV 4:4:4采样，每一个 Y 对应一组 UV 分量。</li>
<li>YUV 4:2:2采样，每两个 Y 共用一组 UV 分量。</li>
<li>YUV 4:2:0采样，每四个 Y 共用一组 UV 分量。</li>
</ul>


<p>用三个图来直观地表示采集的方式吧，以黑点表示采样该像素点的 Y 分量，以空心圆圈表示采用该像素点的 UV 分量。</p>

<p><img src="http://ww1.sinaimg.cn/large/72f96cbajw1f5lsdr21poj20pu07374w.jpg" alt="" /></p>

<p>色彩二次抽样一般发生在取样时，一些专业的相机以 4:4:4 的参数捕捉图像，但大部分情况下对于图片的拍摄是使用 4:2:2 的方式进行的。面向消费者的摄像头装置，比如 iPhone 手机上的摄像头，通常以 4:2:0 的方式进行拍摄。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">videoDataOutput</span><span class="p">.</span><span class="n">videoSettings</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>            <span class="nl">kCVPixelBufferPixelFormatTypeKey</span><span class="p">:</span> <span class="n">Int</span><span class="p">(</span><span class="n">kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange</span><span class="p">)</span>
</span><span class='line'>        <span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<h4>编解码器压缩</h4>

<p>大部分音频和视频都是使用编解码器(codec)来压缩的，编解码器这个术语是由编码器/解码器结合简写得来的(encoder/decoder)。编解码器使用高级压缩算法对需要保存或发送的音频或视频数据进行压缩和编码，同时它还可以将压缩文件解码成适合播放和编辑的媒体资源文件。</p>

<p>视频编解码器(编码器/解码器)是指两个协同运行的压缩-解压算法。使用不同标准的视频编解码器通 常彼此之间互不兼容;也就是说,使用一种标准进行压缩的视频内容无法使用另外一种标准进行解压缩。例如，MPEG-4 Part2 解码器就不能与 H.264 编码器协同运行。这是因为一种算法无法正确地对另外一个算法的输出信号进行解码，然而我们可以在同一软件或硬件中使用多种不同的算法,以支持对多种 格式的文件进行压缩。</p>

<h5>H.264</h5>

<p>H.264，是一种影片压缩标准。H.264 规范是Motion Picture Experts Group(MPEG)所定义的 MPEG-4 的一部分。H.264 遵循早期的 MEPG-1 和 MPEG-2 标准，但是在以更低比特率得到更高图片质量方面有了长足进步，使其更好地用于流媒体文件和移动设备及视频摄像头。</p>

<p>下图是在相同图像质量水平下，采用下列视频标准的比特率对比：M-JPEG，MPEG-4、MPEG-4 Part 2 和 H.264。</p>

<p><img src="http://ww1.sinaimg.cn/large/006tNc79jw1f5mkb08mgfj31ki168799.jpg" width="600"></p>

<p>如图所示，对于视频序列样本来说，使用 H.264 编码器能够比使用 MPEG-4 编码器降低 50% 的比特率(bps)，比 M-JPEG 编码器高6倍。</p>

<h5>H.264 压缩原理</h5>

<p>H.264 与其他形式的 MPEG 压缩一样，通过以下两个维度缩小了视频文件的尺寸：</p>

<ul>
<li>空间：压缩独立视频帧，被称为帧内压缩</li>
<li>时间：通过以组为单位的视频帧压缩冗余数据，这一过程称为帧间压缩</li>
</ul>


<p>帧内压缩通过消除包含在每个独立视频帧内的色彩及结构中的冗余信息来进行压缩，因此可在不降低图片质量的情况下尽可能缩小尺寸。这类压缩同 JEPG 压缩的原理类似。帧内压缩也可以作为有损压缩算法，但通常用于对原始图片的一部分进行处理以生成极高质量的照片。通过这一过程创建的帧称为 I-frames。</p>

<p>在帧间压缩中，很多帧被组合在一起作为一组图片(简称GOP)，对于 GOP 所存在的时间维度的冗余可以被消除。如果想象视频文件中的典型场景，就会有一些特定运动元素的概念，比如行驶的汽车或街上走路的行人，场景的背景环境通常是固定的。固定的背景环境就代表一个时间维度上的冗余，这个冗余就可以通过压缩方式进行消除。</p>

<p>总结一句话：H264 采用的核心算法是帧内压缩和帧间压缩，帧内压缩是生成 I 帧的算法，帧间压缩是生成 B 帧和 P 帧的算法。</p>

<p>图 8 给出了存储在 GOP 中的三个不同类型的帧。</p>

<p><img src="http://ww1.sinaimg.cn/large/72f96cbajw1f5miy74zj8j21dm0noju3.jpg" width="600"></p>

<ul>
<li><p>I-frames</p>

<p>这些帧都是一些单独的帧或关键帧，包含创建完整图片需要的所有数据。每个 GOP 都正好有一个 I-frames。由于它是一个独立帧，其尺寸是最大的，但也是解压最快的。</p></li>
</ul>


<blockquote><p>你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）</p></blockquote>

<ul>
<li><p>P-frames</p>

<p>P-frames 又称为预测帧，P帧表示的是这一帧跟之前的一个 I 帧或 P 帧的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P 帧没有完整画面数据，只有与前一帧的画面差别的数据）</p></li>
<li><p>B-frames</p>

<p>B-frames 又称为双向帧，是基于使用之前和之后的帧信息进行编码后得到的帧。几乎不需要存储空间，但其解压过程会耗费较长时间，因为它依赖于周围其他的帧。
B 帧记录的是本帧与前后帧的差别，换言之，要解码 B 帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。</p></li>
</ul>


<p><br /></p>

<p><img src="http://ww2.sinaimg.cn/large/006tNc79gw1f5mlf72ri8j317y0g2dhe.jpg" width="600"></p>

<p>对M-JPEG格式来说,上述序列中的三个图像分别作为独立的图像(I帧)进行编码和发送,彼此之间互不依赖。</p>

<p><img src="http://ww1.sinaimg.cn/large/006tNc79jw1f5mlfqeuw1j319e0geabo.jpg" width="600"></p>

<p>只有第一个图像(I帧)是将全帧图像信息进行编码。在后面的两个图像(P帧)中，其静态部分(即房子)将参考第一个图像，而仅对运动部分(即正在跑步的人)使用运动矢量进行编码，从而减少发送和存储的信息量。</p>

<h5>H.264 编码标准</h5>

<p>H.264 还支持编码标准，用于确定在整个编码过程中所使用的算法。共定义了 3 个高级标准：</p>

<p>Baseline：基本画质，支持I/P 帧。这个标准通常用于对移动设备的媒体内容进行处理，提供了最低效的压缩，因此经过这个标准压缩后的文件仍较大，但是同时这种方法也是最少计算强度的方法，因为它不支持 B-frames。如果开发者的编译目标是年代比较久远的 iOS 设备，比如 iPhone 3GS，可能需要用到 Baseline 标准。</p>

<p>Main：主流画质，支持 I/P/B 帧。这个标准的计算强度要比 Baseline 的高，因为它使用的算法更多，但可以达到比较高的压缩率。</p>

<p>High：高级画质，在 Main Profile 的基础上增加了8×8内部预测、自定义量化、 无损视频编码和更多的YUV 格式。高标准的方法会得到最高质量的压缩效果，但它也是 3 种方法中计算复杂度最高的，因为所有能用到的编码技术和算法几乎都用到了。</p>

<p><br /></p>

<p>实时直播：</p>

<ul>
<li>低清Baseline Level 1.3</li>
<li>标清Baseline Level 3</li>
<li>半高清Baseline Level 3.1</li>
<li>全高清Baseline Level 4.1</li>
</ul>


<p>存储媒体：</p>

<ul>
<li>低清 Main Level 1.3</li>
<li>标清 Main Level 3</li>
<li>半高清 Main Level 3.1</li>
<li>全高清 Main Level 4.1</li>
</ul>


<p>高清存储：</p>

<ul>
<li>半高清 High Level 3.1</li>
<li>全高清 High Level 4.1</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelKey</span> <span class="cm">/* NSString, H.264 only, one of: */</span>                <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">4</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264Baseline30</span> <span class="cm">/* Baseline Profile Level 3.0 */</span>        <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">4</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264Baseline31</span> <span class="cm">/* Baseline Profile Level 3.1 */</span>        <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">4</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264Baseline41</span> <span class="cm">/* Baseline Profile Level 4.1 */</span>        <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">5</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264BaselineAutoLevel</span> <span class="cm">/* Baseline Profile Auto Level */</span> <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_9</span><span class="p">,</span> <span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264Main30</span> <span class="cm">/* Main Profile Level 3.0 */</span>                <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">4</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264Main31</span> <span class="cm">/* Main Profile Level 3.1 */</span>                <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">4</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264Main32</span> <span class="cm">/* Main Profile Level 3.2 */</span>                <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">5</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264Main41</span> <span class="cm">/* Main Profile Level 4.1 */</span>                <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_8</span><span class="p">,</span> <span class="mi">5</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264MainAutoLevel</span> <span class="cm">/* Main Profile Auto Level */</span>        <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_9</span><span class="p">,</span> <span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264High40</span> <span class="cm">/* High Profile Level 4.0 */</span>                <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_9</span><span class="p">,</span> <span class="mi">6</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264High41</span> <span class="cm">/* High Profile Level 4.1 */</span>                <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_9</span><span class="p">,</span> <span class="mi">6</span><span class="n">_0</span><span class="p">);</span>
</span><span class='line'><span class="n">AVF_EXPORT</span> <span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">AVVideoProfileLevelH264HighAutoLevel</span> <span class="cm">/* High Profile Auto Level */</span>        <span class="n">NS_AVAILABLE</span><span class="p">(</span><span class="mi">10</span><span class="n">_9</span><span class="p">,</span> <span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h5>视频码率(bitRate)</h5>

<p>码率是指单位时间内传输的数据位数。视频体积=视频码率*时间，由此可见固定长度的视频，码率是决定大小的唯一因素。视频码率决定着视频的压缩效果，也决定了视频是质量。码率越高，质量越好，体积越大。码率越低，体积越小，视频质量也越差。
编码时，根据码率可以分为固定码率(CBR)编码和可变码率(VBR)编码。</p>

<ul>
<li><p>固定码率：指编码器输出的码率一直为一个固定值，这种编码方式计算量小，编码速度快，但是编码效果不怎么好。对于画面变化大的视频片段，由于码率限制，导致视频非常模糊，然而对于画面变化小的片段，却会造成码率浪费。</p></li>
<li><p>可变码率：指编码器的输出码率可以根据编码器的输入源信号的复杂度自适应的调整，这种方式编码效果比较好</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">codecSettings</span> <span class="o">=</span> <span class="p">[</span><span class="nl">AVVideoAverageBitRateKey</span><span class="p">:</span> <span class="mi">2000000</span><span class="p">,</span> <span class="nl">AVVideoProfileLevelKey</span><span class="p">:</span> <span class="n">AVVideoProfileLevelH264BaselineAutoLevel</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="nl">videoCompressionSettings</span><span class="p">:</span> <span class="p">[</span><span class="nl">String</span><span class="p">:</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nl">AVVideoCodecKey</span><span class="p">:</span> <span class="n">AVVideoCodecH264</span><span class="p">,</span> <span class="nl">AVVideoCompressionPropertiesKey</span><span class="p">:</span> <span class="n">codecSettings</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">videoWriterInput</span> <span class="o">=</span> <span class="bp">AVAssetWriterInput</span><span class="p">(</span><span class="nl">mediaType</span><span class="p">:</span> <span class="n">AVMediaTypeVideo</span><span class="p">,</span> <span class="nl">outputSettings</span><span class="p">:</span> <span class="n">videoCompressionSettings</span><span class="p">,</span> <span class="nl">sourceFormatHint</span><span class="p">:</span> <span class="n">videoFormatHint</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<h2>Reference</h2>

<p><a href="http://item.jd.com/11742630.html">AV Foundation 开发秘籍</a></p>

<p><a href="http://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html">图文详解YUV420数据格式</a></p>

<p><a href="http://itony.me/808.html">iOS RTMP 视频直播开发笔记（3）- 了解 H.264 编码</a></p>

<p><a href="http://blog.csdn.net/voipmaker/article/details/8451577">H264 GOP 扫盲</a></p>

<p><a href="http://www.axis.com/files/whitepaper/wp_h264_34203_cn_0901_lo.pdf">H.264视频压缩标准</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译] 揭秘控制器视图的加载过程]]></title>
    <link href="http://limon.top/controller-load-process/"/>
    <updated>2016-02-02T04:20:57+08:00</updated>
    <id>http://limon.top/controller-load-process</id>
    <content type="html"><![CDATA[<p>原文链接:
<a href="http://szulctomasz.com/ios-uiviewcontrollers-view-loading-process-demystified/">iOS: UIViewController’s view loading process demystified</a></p>

<p><a href="https://twitter.com/NatashaTheRobot">@NatashaTheRobot</a>在她的博客里发过一篇关于测试控制器及视图加载问题的文章<a href="http://natashatherobot.com/ios-testing-view-controllers-swift/">The One Weird Trick For Testing View Controllers in Swift</a></p>

<blockquote><p>她写道：
    这里的关键是苹果重载了控制器视图的getter去调用加载视图的方法，并做了许多我们没有权限访问的其它事情。如果有谁深入了解过其中的工作原理，尽情地说出来吧。</p></blockquote>

<p>了解背后的工作原理确实是一个很有趣的事情。在她的鼓励下，我开始进行深入的探索。</p>

<p>我发现有两种情况：控制器被设置为 window 的根控制器或者 控制器不作为根控制器（例如，当你想要测试视图控制器，并从 Storyboard 中实例化了一个时）</p>

<h2>控制器作为根控制器</h2>

<pre><code>if self.window == nil {
    self.window = UIWindow(frame: UIScreen.mainScreen().bounds)
}

let storyboard = UIStoryboard(name: "Main", bundle: NSBundle.mainBundle())
let vc = storyboard.instantiateViewControllerWithIdentifier("ViewController")
self.window!.rootViewController = vc
</code></pre>

<p>比如说，这部分程序流运行在 <code>-application:DidFinishLaunchingWithOptions:</code> 方法中，
<img src="http://szulctomasz.com/wp-content/uploads/2015/08/ex-1.png" alt="" />
<code>UIWindow</code> 的 <code>-makeKeyAndVisible</code> 是第一个被调用的方法，此方法调用了 UIWindow 的私有方法 <code>-addRootViewControllerViewIfPossible</code> 去为其根控制器添加 view，并显示出来。<code>UIWindow</code>  获取根控制器的 <code>view</code> 属性之后，就开始了视图加载的一系列过程，首先被调用的方法是 <code>-loadViewIfRequired</code>，此方法再调用 <code>-loadView</code> 方法。<code>-loadView</code> 方法调用 <code>UIViewController</code> 的的内部方法来加载 Nib 以达到设置视图的目的。</p>

<p>今年（2015年）的 WWDC 上有个非常好的演讲，介绍了 <code>storyboard</code> 及 <code>nibs</code> 在运行时是如何运作的。<a href="https://developer.apple.com/videos/wwdc/2015/?id=407">Implementing UI Design in Interface Builder</a></p>

<p>在 <code>loadView</code> 设置好后，控制器调用它内部的方法 <code>-_window</code>，并读取了诸如<code>preferedInterfaceOrientation</code>、<code>supportedInterfaceOrientations</code>、<code>shouldAutorotate</code>的许多设置。事实上，控制器调用了 <code>-_window</code> 许多次，此外也调用了许多其它方法。</p>

<p>接着，<code>-viewDidLoad</code> 方法被调用，私有 <code>-__viewWillAppear</code> 调用 <code>-viewWillAppear</code>。视图即将被呈现出来，所以 <code>-willMoveToWindow:</code> <code>-willMoveToSuperview:</code> 和私有 <code>-_didMoveFromWindow:toWindow:</code> 等方法被调用。</p>

<p>下一步是为视图作自动布局，所以 <code>layoutMarginsDidChange, didMoveToWindow, didMoveToSuperview, updateViewConstraints, updateConstraints, layoutSublayersOfLayer, viewWillLayoutSubviews, layoutSubviews</code> 等一系列方法被调用</p>

<p>最后，<code>-viewDidAppear:</code>被调用了，视图也呈现出来了。</p>

<h4>.</h4>

<h2>普通控制器的加载测试</h2>

<p>这是另外一个值得去研究的重要情况。在这种情况下，你不用创建 <code>window</code> 并把你的 <code>view controller</code> 加到其上来进行测试，只需要通过storyboard创建控制器的实例以进行测试。在看了 Natasha 的文章之前，我只知道直接通过访问控制器的 <code>view</code> 属性来获取视图。现在我知道在 iOS9 之后，<code>-loadViewIfNeeded</code> 方法和访问属性 <code>view</code> 的行为是一样的。并且在<a href="https://github.com/orta">Ørta</a>的推荐下，我知道了两个更好的方法 去测试控制器视图的加载并确保其可用。<code>-beginAppearanceTransition:animated</code> 和 <code>-endApperanceTransition</code>。<a href="https://github.com/artsy/eigen/blob/master/Artsy_Tests/Extensions/UIViewController+PresentWithFrame.m#L20-L22">这是他推荐的方法</a></p>

<h3>直接访问View属性</h3>

<p>让我们看看直接访问 <code>view</code> 时的情况。</p>

<pre><code>let storyboard = UIStoryboard(name: "Main", bundle: NSBundle.mainBundle())
let vc = storyboard.instantiateViewControllerWithIdentifier("ViewController")
_ = vc.view
</code></pre>

<p><img src="http://szulctomasz.com/wp-content/uploads/2015/08/ex-2.png" alt="" /></p>

<p>好吧，许多方法没被调用。<code>window</code> 为 <code>nil</code>，视图可以被访问和加载，图上的加载过程却在 <code>-viewDidLoad</code> 中就结束了，所以我认为还有许多方法没被找出来。</p>

<p>让我们看看 <code>-beginApperanceTransition:animated:</code> 是怎样工作的。</p>

<h3>beginApperanceTransition:animated</h3>

<pre><code>let storyboard = UIStoryboard(name: "Main", bundle: NSBundle.mainBundle())
let vc = storyboard.instantiateViewControllerWithIdentifier("ViewController")
vc.beginAppearanceTransition(true, animated: false)
vc.endAppearanceTransition()
</code></pre>

<p><img src="http://szulctomasz.com/wp-content/uploads/2015/08/ex-3.png" alt="" /></p>

<p>非常好，这次的加载过程比第一个要详细。可以看到，这里 <code>window</code> 同样是 <code>nil</code>，所以控制器的视图，没有出现在加载过程中，也没有设置布局的代码在运行，仅仅是控制器的一些设置。</p>

<blockquote><p>译者：这里可能很难理解，可以结合本文的三个图，图都是分三列，分别为 <code>UIWindow</code>、<code>UIViewController</code>、<code>UIView</code>，这里说 <code>window</code> 同样是 <code>nil</code> 的意思是，<code>UIWindow</code> 列没出现东西，原因是控制器不是根控制器，这里仅仅测试单独一个控制器。作者在这里想表达的意思是</p></blockquote>

<h2>总结</h2>

<p>现在应该知道，视图的加载过程取决于控制器的上下文。</p>

<p>在第一个例子中，控制器作为根控制器，所以控制器和视图都进行了许多设置。</p>

<p>在最后的一个例子中，因为没有 <code>UIWindow</code>，只有控制器初始化了，连视图也没有初始化的需要 必要。这种情况就类似于模拟 <code>present</code> 一个控制器，因此 <code>-viewWillAppear</code> 和 <code>-viewDidAppear</code> 方法被调用了。这在某些情况下或许很重要。</p>

<p>最后，我要再谈谈第二个例子。
在不知道 <code>-beginApperanceTransition:animated</code> 之前，我以为 viewWill/viewDid 会被调用，但是并没有，就如以上图二所示。Ørta 提供的方法可能是测试控制器的最好途径之一。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Realm Thread 浅析]]></title>
    <link href="http://limon.top/RealmThread/"/>
    <updated>2016-01-14T02:27:14+08:00</updated>
    <id>http://limon.top/RealmThread</id>
    <content type="html"><![CDATA[<p>两个同一：同一个 realm、同一个线程，两者缺一不可。</p>

<p>打开 App，首先从 Realm 中获取首页的数据，此时在 <strong>主线程</strong> 调用 <code>-fetchArticlesFromRealmByType(.Home)</code>，此方法返回一个元组： <code>result: (articles: [Article], articleObjects: [ArticleObject])</code>，前者是模型，后者是 Realm 的 <code>Object</code>。</p>

<p>然后再进行网络请求，网络请求完之后，<strong>主线程</strong> 更新 UI，并保存数据最新的数据和删除旧的数据（[ArticleObject]）。
保存数据直接可以实例化一个 Realm，所以不需要考虑 <strong>两个同一</strong>。</p>

<p>重点讲删除数据的两个同一：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">fetchArticlesFromRealmByType</span><span class="p">(</span><span class="nl">articleType</span><span class="p">:</span> <span class="n">ArticleType</span><span class="p">,</span> <span class="nl">result</span><span class="p">:</span> <span class="p">(</span><span class="nl">articles</span><span class="p">:</span> <span class="p">[</span><span class="n">Article</span><span class="p">],</span> <span class="nl">articleObjects</span><span class="p">:</span> <span class="p">[</span><span class="n">ArticleObject</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 省略部分代码...</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 成功从本地数据库中获取数据之后，在 **主线程*** 回调，在外面更新 UI，并持有 articleObjects，待网络请求完，删除此 articleObjects</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">articleRealmObjects</span> <span class="o">=</span> <span class="n">realm</span><span class="p">.</span><span class="n">objects</span><span class="p">(</span><span class="n">ArticleObject</span><span class="p">)</span>
</span><span class='line'>  <span class="n">result</span><span class="p">(</span><span class="nl">articles</span><span class="p">:</span> <span class="n">articles</span><span class="p">,</span> <span class="nl">articleObjects</span><span class="p">:</span> <span class="n">articleRealmObjects</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 注意，Object 不能切换线程，意思就是说，你如果在 Background 线程得到 articleRealmObjects，不能再切换到主线程回调出去，推荐使用通知。</span>
</span><span class='line'>  <span class="n">Queue</span><span class="p">.</span><span class="n">Background</span><span class="p">.</span><span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">let</span> <span class="n">articleRealmObjects</span> <span class="o">=</span> <span class="n">realm</span><span class="p">.</span><span class="n">objects</span><span class="p">(</span><span class="n">ArticleObject</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Queue</span><span class="p">.</span><span class="n">Main</span><span class="p">.</span><span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">result</span><span class="p">(</span><span class="nl">articles</span><span class="p">:</span> <span class="n">articles</span><span class="p">,</span> <span class="nl">articleObjects</span><span class="p">:</span> <span class="n">articleRealmObjects</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">deleteObject</span><span class="p">(</span><span class="nl">articleObjects</span><span class="p">:</span> <span class="p">[</span><span class="n">ArticleObject</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">guard</span> <span class="k">let</span> <span class="n">articleObjects</span> <span class="o">=</span> <span class="n">articleObjects</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">articleObjects</span><span class="p">.</span><span class="n">first</span><span class="o">?</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">articleObjects</span><span class="p">.</span><span class="n">first</span><span class="o">?</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">articleObjects</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>同一个线程</h3>

<p>待网络请求完后，想要删除旧的 <code>articleObjects</code>，应该在 <code>articleObjects</code> 同一线程内删除，在此例子中，<code>articleObjects</code> 是从 <code>Queue.Main</code> 中得到，那删除时也要在此线程删除，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">Queue</span><span class="p">.</span><span class="n">Main</span><span class="p">.</span><span class="n">execute</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="s">&quot;delete action on thread: \(NSThread.currentThread())&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">deleteObject</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">articleObjects</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果打印出来的内存地址和在 <code>-fetchArticlesFromRealmByType(.Home)</code> 打印的不同，此时就会 Crash: <code>Realm accessed from incorrect thread.</code></p>

<blockquote><p>如果是在串行队列中，需要持有此队列，就算 <code>-dispatch_queue_create(key, _)</code> 中的 key 每次创建都是同一个 key，也不能保证所有串行任务都在同一个队列对象中。</p></blockquote>

<h3>同一个 realm</h3>

<p>可以直接从 <code>ArticleObject</code> 获取 <code>realm</code>，前提是数组内所有的 Object 都是在同一个 <code>realm</code> 内。(还没遇到过，一个数组内放不同 realm 的 Object 这样变态的需求 -.- )</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">articleObjects</span><span class="p">.</span><span class="n">first</span><span class="o">?</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">articleObjects</span><span class="p">.</span><span class="n">first</span><span class="o">?</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">articleObjects</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里值得注意的是，删除了此 <code>articleObject</code>之后，如果你还访问了此对象的自定义属性，就会 Crash: <code>Object has been deleted or invalidated.</code></p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">articleObject</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">articleObject</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
</span><span class='line'>  <span class="n">print</span><span class="p">(</span><span class="n">articleObject</span><span class="p">.</span><span class="n">title</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为 <code>articleObject</code> 已经无效了，因此稳妥点，在访问前先判断此 <code>Object</code> 的有效性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">func</span> <span class="nf">deleteObject</span><span class="p">(</span><span class="nl">articleObjects</span><span class="p">:</span> <span class="p">[</span><span class="n">ArticleObject</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">guard</span> <span class="k">let</span> <span class="n">articleObject</span> <span class="o">=</span> <span class="n">articleObjects</span><span class="p">.</span><span class="n">first</span> <span class="k">where</span> <span class="o">!</span><span class="n">articleObject</span><span class="p">.</span><span class="n">invalidated</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">articleObject</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">isEmpty</span> <span class="o">??</span> <span class="nb">true</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">try</span><span class="o">?</span> <span class="n">articleObject</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">write</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">articleObject</span><span class="p">.</span><span class="n">realm</span><span class="o">?</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 <a href="http://nshipster.com/new-years-2016/#swiftier-gcd">NSHipster</a> 找到的 GCD 封装</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">protocol</span> <span class="n">ExcutableQueue</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="nl">queue</span><span class="p">:</span> <span class="kt">dispatch_queue_t</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">extension</span> <span class="n">ExcutableQueue</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">func</span> <span class="n">execute</span><span class="p">(</span><span class="nl">closure</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="n">closure</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">enum</span> <span class="nl">Queue</span><span class="p">:</span> <span class="n">ExcutableQueue</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Main</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">UserInteractive</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">UserInitiated</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Utility</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Background</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">var</span> <span class="nl">queue</span><span class="p">:</span> <span class="kt">dispatch_queue_t</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">switch</span> <span class="nb">self</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">Main</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">dispatch_get_main_queue</span><span class="p">()</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">UserInteractive</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">QOS_CLASS_USER_INTERACTIVE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">UserInitiated</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">QOS_CLASS_USER_INITIATED</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">Utility</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">QOS_CLASS_UTILITY</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">case</span> <span class="p">.</span><span class="nl">Background</span><span class="p">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">QOS_CLASS_BACKGROUND</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug 模式与 Release 模式的区分]]></title>
    <link href="http://limon.top/debugbuild/"/>
    <updated>2016-01-08T11:31:30+08:00</updated>
    <id>http://limon.top/debugbuild</id>
    <content type="html"><![CDATA[<h1>Debug 模式与 Release 模式的区分</h1>

<p><br />
区分 Debug 模式与 Release 模式有两种方法，此文的目的是告诉读者尽量避免用 <code>-DDEBUG</code>。</p>

<h4>第一种方法：</h4>

<p>在 (Build Settings -> Swift Compiler - Custom Flags) 中加入 <code>-DDEBUG</code>，
<a href="http://stackoverflow.com/questions/24111854/in-absence-of-preprocessor-macros-is-there-a-way-to-define-practical-scheme-spe/#answer-24112024">Stackoverflow</a>。</p>

<p><img src="http://i.stack.imgur.com/dqp5H.png" alt="" /></p>

<p>但是在 NSHipster 中有提到<strong><em>不推荐</em></strong>此方法  <a href="http://nshipster.com/new-years-2016/#avoiding--ddebug-in-swift">Avoiding -DDEBUG in Swift</a></p>

<p><br /></p>

<h4>第二种方法</h4>

<p>通过 Preprocessor Macros (预处理宏命令) 来区分模式。</p>

<p><br /></p>

<p>1.新建一个 <code>PreProcessorMacros.h</code> 文件，代码如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">PreProcessorMacros</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifndef PreProcessorMacros_h</span>
</span><span class='line'><span class="cp">#define PreProcessorMacros_h</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">BOOL</span> <span class="k">const</span> <span class="n">DEBUG_BUILD</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">PreProcessorMacros</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#ifdef DEBUG</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="k">const</span> <span class="n">DEBUG_BUILD</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="k">const</span> <span class="n">DEBUG_BUILD</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<p>2.在 Bridged Header: <code>#import "PreProcessorMacros.h"</code></p>

<blockquote><p>也可直接把步骤一的代码放进 Bridged Header</p></blockquote>

<p><br /></p>

<p>3.测试</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">if</span> <span class="n">DEBUG_BUILD</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;It&#39;s Debug build&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;It&#39;s Release build&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>⌘⇧&lt;</strong> 进入下图可模式切换</p>

<p><img src="https://raw.githubusercontent.com/Limon-O-O/DEBUGBUILD/master/images/switch.png" alt="" /></p>

<p><br /></p>

<h2>原理</h2>

<p>关键的代码在：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="cp">#ifdef DEBUG</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="k">const</span> <span class="n">DEBUG_BUILD</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="k">const</span> <span class="n">DEBUG_BUILD</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>此处的 <code>DEBUG</code> 究竟来自哪？</p>

<p>进入 &lsquo;Build Settings&rsquo; -> 搜索 &lsquo;Preprocessor Macros&#8217;，真相大白</p>

<p><img src="https://raw.githubusercontent.com/Limon-O-O/DEBUGBUILD/master/images/PreprocessorMacros.png" alt="" /></p>

<p><br />
源码：<a href="https://github.com/Limon-O-O/DEBUGBUILD">DEBUGBUILD</a></p>

<p>抽取于干货极多的：<a href="http://nshipster.com/new-years-2016/">Reader Submissions -
New Year&rsquo;s 2016</a>  🍺</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[花式自定义下标]]></title>
    <link href="http://limon.top/subscriptswift/"/>
    <updated>2016-01-05T17:56:42+08:00</updated>
    <id>http://limon.top/subscriptswift</id>
    <content type="html"><![CDATA[<h1>花式自定义下标</h1>

<h3>一、枚举作 Key</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">dictionaryOne</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>        <span class="n">MyDictionaryKeys</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="nl">rawValue</span><span class="p">:</span> <span class="s">&quot;Limon&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">MyDictionaryKeys</span><span class="p">.</span><span class="n">Age</span><span class="p">.</span><span class="nl">rawValue</span><span class="p">:</span> <span class="n">Int</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="k">let</span> <span class="n">name</span> <span class="o">=</span> <span class="n">dictionaryOne</span><span class="p">[.</span><span class="n">Name</span><span class="p">]</span><span class="o">!</span>
</span><span class='line'><span class="k">let</span> <span class="n">age</span> <span class="o">=</span> <span class="n">dictionaryOne</span><span class="p">[.</span><span class="n">Age</span><span class="p">]</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">enum</span> <span class="nl">MyDictionaryKeys</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Name</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">Age</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">extension</span> <span class="n">Dictionary</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">subscript</span><span class="p">(</span><span class="nl">customKey</span><span class="p">:</span> <span class="n">MyDictionaryKeys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyObject</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">guard</span> <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">customKey</span><span class="p">.</span><span class="n">rawValue</span> <span class="kt">as</span><span class="o">?</span> <span class="n">Key</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="nb">self</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">value</span> <span class="kt">as</span><span class="o">?</span> <span class="n">String</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">extension</span> <span class="bp">NSDictionary</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">subscript</span><span class="p">(</span><span class="nl">customKey</span><span class="p">:</span> <span class="n">MyDictionaryKeys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyObject</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">objectForKey</span><span class="p">(</span><span class="n">customKey</span><span class="p">.</span><span class="n">rawValue</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<h3>二、声明 Key 时，同时定义 Value 的类型</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">userID</span> <span class="o">=</span> <span class="n">dictionaryTwo</span><span class="p">[.</span><span class="n">tip_UserIDKey</span><span class="p">]</span><span class="o">!</span>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="n">userID</span> <span class="kt">is</span> <span class="n">Int</span><span class="p">)</span> <span class="c1">// Always true</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">extension</span> <span class="n">DictionaryKeys</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="k">let</span> <span class="n">tip_UserIDKey</span> <span class="o">=</span> <span class="n">DictionaryKey</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">?&gt;</span><span class="p">(</span><span class="s">&quot;userID&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">extension</span> <span class="bp">NSDictionary</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">subscript</span><span class="p">(</span><span class="nl">key</span><span class="p">:</span> <span class="n">DictionaryKey</span><span class="o">&lt;</span><span class="n">String</span><span class="o">?&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>        <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">objectForKey</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="kt">as</span><span class="o">?</span> <span class="n">String</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">subscript</span><span class="p">(</span><span class="nl">key</span><span class="p">:</span> <span class="n">DictionaryKey</span><span class="o">&lt;</span><span class="n">Int</span><span class="o">?&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Int</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>        <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">objectForKey</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">value</span><span class="p">)</span> <span class="kt">as</span><span class="o">?</span> <span class="n">Int</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">DictionaryKeys</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">private</span> <span class="k">init</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="n">DictionaryKey</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;:</span> <span class="n">DictionaryKeys</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">let</span> <span class="nl">value</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">init</span><span class="p">(</span><span class="n">_</span> <span class="nl">key</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">key</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<h3>三、用枚举获取 Set 的元素</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="k">let</span> <span class="n">qqAccount</span> <span class="o">=</span> <span class="n">accountSet</span><span class="p">[.</span><span class="n">QQ</span><span class="p">]</span>
</span><span class='line'><span class="k">let</span> <span class="n">weChatAccount</span> <span class="o">=</span> <span class="n">accountSet</span><span class="p">[.</span><span class="n">WeChat</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">print</span><span class="p">(</span><span class="s">&quot;样式三、qqAppID: \(qqAccount!.appID)  weChatAppID: \(weChatAccount!.appID)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<p>源码：<a href="https://github.com/Limon-catch/SubscriptSwift">SubscriptSwift</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matching Option]]></title>
    <link href="http://limon.top/matching-option/"/>
    <updated>2015-12-23T22:36:43+08:00</updated>
    <id>http://limon.top/matching-option</id>
    <content type="html"><![CDATA[<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>    "articles": [
</span><span class='line'>        {
</span><span class='line'>            "type": "app", // AppSo文章
</span><span class='line'>            "cellHeight": "100"
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            "type": "number", // 数独文章
</span><span class='line'>            "cellHeight": "200"
</span><span class='line'>        },
</span><span class='line'>        {
</span><span class='line'>            "type": "mindStore", // MindStore文章
</span><span class='line'>            "cellHeight": "300"
</span><span class='line'>        }
</span><span class='line'>    ]
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>假设服务器返回以上的JSON，客户端需要根据文章类型来作不同的布局。</p>

<p>第一时间可能会想到以下的方法来switch：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='Swift'><span class='line'><span class="k">let</span> <span class="n">typeString</span> <span class="o">=</span> <span class="s">&quot;app&quot;</span>
</span><span class='line'><span class="k">switch</span> <span class="n">typeString</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;app&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;AppSo Article&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="s">&quot;number&quot;</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Number Article&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">default</span><span class="o">:</span>
</span><span class='line'>    <span class="k">break</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<p>较为优雅的方法是用<code>enum</code>来管理类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='Swift'><span class='line'><span class="k">enum</span> <span class="nl">Occupation</span><span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">AppSo</span> <span class="o">=</span> <span class="s">&quot;app&quot;</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">Number</span> <span class="o">=</span> <span class="s">&quot;number&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">typeString</span> <span class="o">=</span> <span class="s">&quot;mindStore&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">switch</span> <span class="n">Occupation</span><span class="p">(</span><span class="nl">rawValue</span><span class="p">:</span> <span class="n">typeString</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">AppSo</span><span class="o">?:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;AppSo Article&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="p">.</span><span class="n">Number</span><span class="o">?:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Number Article&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="nb">nil</span><span class="o">:</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Article?&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br /></p>

<p>抽取于：<a href="http://www.figure.ink/blog/2015/12/6/matching-with-swifts-optional-pattern?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=web&amp;utm_source=This_Week_in_Swift_65">Matching with Swift&rsquo;s Optional Pattern</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优雅地自定义XibView]]></title>
    <link href="http://limon.top/customxibview/"/>
    <updated>2015-12-23T21:38:17+08:00</updated>
    <id>http://limon.top/customxibview</id>
    <content type="html"><![CDATA[<h2>优雅地自定义XibView</h2>

<p>好习惯，先上<a href="https://github.com/Limon-catch/XibView">源码</a>。</p>

<p>先创建一个UIView文件和一个Xib文件，在Xib文件里设置如下，</p>

<p><img src="https://raw.githubusercontent.com/Limon-catch/XibView/master/XibView/Image/XibView_Step1.png" alt="" /></p>

<p>在UIView文件中，不是用<code>-awakeFromNib()</code>作为构造器，而是正常的<code>-init(frame: CGRect)</code>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="kr">override</span> <span class="nf">init</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="bp">CGRect</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">frame</span><span class="p">:</span> <span class="n">frame</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">xibSetup</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而<code>-xibSetup()</code>才是关键，具体可看源码。</p>

<p><br />
如果需要UIView和Xib文件建立控件属性关联，是设置Xib文件的File`s Owner，<strong><em>而不是设置View的Custom Class</em></strong>。</p>

<p><img src="https://raw.githubusercontent.com/Limon-catch/XibView/master/XibView/Image/XibView_Step2.png" alt="" /></p>

<p>设置了File`s Owner就可以像往常一样拖线了。</p>

<p>如果想在<code>Main.storyboard</code>文件中直接使用此Xib，同时也想在SB中设置属性，那怎么使用呢？</p>

<ol>
<li>在SB中加入一个UIView，将其Class设置成<code>XibView</code><br /></li>
<li>使用<code>@IBInspectable</code></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">@</span><span class="n">IBInspectable</span> <span class="k">var</span> <span class="nl">title</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>  <span class="kr">get</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">xibLabel</span><span class="p">.</span><span class="n">text</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="kr">set</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">xibLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">newValue</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><br />
添加了<code>@IBInspectable</code>之后，就可以像系统自带的控件一样设置属性了。</p>

<p><img src="https://raw.githubusercontent.com/Limon-catch/XibView/master/XibView/Image/XibView_Step3.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理 - ARC]]></title>
    <link href="http://limon.top/nei-cun-guan-li-arc/"/>
    <updated>2015-01-22T18:20:16+08:00</updated>
    <id>http://limon.top/nei-cun-guan-li-arc</id>
    <content type="html"><![CDATA[<h2>什么是ARC</h2>

<p>Automatic Reference Counting，自动引用计数，即ARC。</p>

<p>在ARC下，不需用retain,release,autorelease,dealloc来管理内存，它提供了自动评估内存生存期的功能，并且在编译期间自动加入合适的管理内存的方法。编译器也会自动生成dealloc函数。</p>

<h3>ARC工作原理</h3>

<p>ARC并不是一项运行时的服务，实际上它是由Clang front-end提供的两段过程。下图演示了这两段过程。在front-end段时，Clang检查每个预处理文件的对象和属性。然后它跟据一些固定的规则将retain，release和autorelease语句加入其中。</p>

<blockquote><p>实际上，ARC在调用retain,release,autorelease,dealloc方法时，并不通过Objective-C消息派送机制，而是直接调用C。比如，ARC会调用与retain等价的objc_retain</p></blockquote>

<p><img src="http://limons-gitimage.stor.sinaapp.com/CFigure4.gif" alt="" /></p>

<p>举例来说：</p>

<ul>
<li>如果对象被分配内存并处于一个方法当中，它会在这个方法的结尾处获得一个release语句</li>
<li>如果是一个类属性，它的release语句会加入到类的dealloc方法中</li>
<li>如果这个对象是用来返回的或者它是一个容器对象，它会加入一个autorelease语句</li>
<li>如果这个对象是弱引用，把它放在一边不管它。</li>
</ul>


<blockquote><p>译于：<a href="http://www.drdobbs.com/mobile/automatic-reference-counting-on-ios/240000820">Automatic Reference Counting on iOS</a></p></blockquote>

<h3>代码演示</h3>

<h4>MRC下</h4>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>@class Bar;
</span><span class='line'>@interface Foo
</span><span class='line'>{
</span><span class='line'>@private
</span><span class='line'>    NSString *myStr;
</span><span class='line'>}
</span><span class='line'>@property (readonly) NSString *myStr;
</span><span class='line'>  
</span><span class='line'>- (Bar *)foo2Bar:(NSString *)aStr;
</span><span class='line'>- (Bar *)makeBar;
</span><span class='line'>//...
</span><span class='line'>@end
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>@implementation Foo;
</span><span class='line'>@dynamic myStr;
</span><span class='line'>  
</span><span class='line'>– (Bar *)foo2Bar:(NSString *)aStr
</span><span class='line'>{
</span><span class='line'>    Bar *tBar;
</span><span class='line'>      
</span><span class='line'>    if (![self.myStr isEqualToString:aStr])
</span><span class='line'>    {
</span><span class='line'>        [aStr retain];
</span><span class='line'>        [myStr release];
</span><span class='line'>        myStr = aStr;
</span><span class='line'>    }  
</span><span class='line'>    return ([self makeBar]);
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>- (Bar *)makeBar
</span><span class='line'>{
</span><span class='line'>    Bar *tBar
</span><span class='line'>    //...
</span><span class='line'>    //... conversion code goes here
</span><span class='line'>    //...
</span><span class='line'>    [tBar autorelease];
</span><span class='line'>    return (tBar);
</span><span class='line'>}
</span><span class='line'>//...
</span><span class='line'>  
</span><span class='line'>- (void)dealloc
</span><span class='line'>{
</span><span class='line'>    [myStr release];
</span><span class='line'>    [super dealloc];
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h4>ARC下</h4>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>@class Bar;
</span><span class='line'>@interface Foo
</span><span class='line'>{
</span><span class='line'>@private
</span><span class='line'>    NSString *myStr;
</span><span class='line'>}
</span><span class='line'>@property(readonly) NSString *myStr;
</span><span class='line'>  
</span><span class='line'>- (Bar *)foo2Bar:(NSString *)aStr;
</span><span class='line'>- (Bar *)makeBar;
</span><span class='line'>//...
</span><span class='line'>@end
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>@implementation Foo;
</span><span class='line'>@dynamic myStr;
</span><span class='line'>  
</span><span class='line'>– (Bar *)foo2Bar:(NSString *)aStr
</span><span class='line'>{
</span><span class='line'>    Bar *tBar;
</span><span class='line'>      
</span><span class='line'>    if (![self.myStr isEqualToString:aStr])
</span><span class='line'>    {
</span><span class='line'>        myStr = aStr;
</span><span class='line'>    }  
</span><span class='line'>    return ([self makeBar]);
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>- (Bar *)makeBar
</span><span class='line'>{
</span><span class='line'>    Bar *tBar
</span><span class='line'>    //...
</span><span class='line'>    //... conversion code goes here
</span><span class='line'>    //...
</span><span class='line'>    return (tBar);
</span><span class='line'>}
</span><span class='line'>//...
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<blockquote><p>以上代码来源于：<a href="http://www.drdobbs.com/mobile/automatic-reference-counting-on-ios/240000820">Automatic Reference Counting on iOS</a></p></blockquote>

<h2>ARC下内存管理 &mdash; 内存管理语义</h2>

<p>ARC帮助我们解决90%内存管理为题，剩余的10%包括：</p>

<ul>
<li>属性(property)的内存管理语义是用strong、还是weak？</li>
<li>循环引用（retain cycle）问题</li>
<li>CoreFoundation对象不归ARC管理</li>
</ul>


<h3>属性</h3>

<p>属性(property)是Objective-C的一项特性，用于封装对象中的数据。Objective-C对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过getter、setter来访问。</p>

<p><code>@property(nonatomic, strong) NSArray *emailList;</code></p>

<p>此<code>@property</code>会自动生成三个东西：_emailList实例变量、getter、setter</p>

<p>属性用于封装数据，而数据则要有“具体的所有权语义”(concrete ownership semantic)，也称为内存管理语义。</p>

<p>回归本题，在ARC下，我们通常用<strong>内存管理语义</strong>来管理内存，下面这一组语义仅会影响setter。例如，用setter设定一个新值时，它是应该“保留”(retain)此值呢，还是只将其赋给底层实例变量就好？这些取决于你是用strong，还是copy，还是assign等</p>

<ul>
<li><p><code>assign</code>  对“纯量类型”(scalar type)的简单赋值</p>

<pre><code>  -(void)setState:(int)State{  
      _state = state;  
  }
</code></pre></li>
<li><p><code>unsafe_unretained</code>  此语义与<code>assign</code>相同，但是它适用于&#8221;对象类型&#8221;，该语义表达一种&#8221;非拥有关系&#8221;(unretained),当对象被销毁时，属性值不会自动清空(&ldquo;不安全&rdquo;,unsafe)，这一点与<code>weak</code>有区别</p></li>
<li><p><code>weak</code>  该语义表达一种&#8221;非拥有关系&#8221;，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，即仅作简单赋值，类似<code>assign</code>，当对象销毁，属性值被赋值为<code>nil</code></p></li>
<li><p><code>strong</code>  该语义表达一种&#8221;拥有关系&#8221;，为这种属性值设置新值时，设置方法会先保留新值，再释放旧值，最后把新值设置上去</p>

<pre><code>  -(void)setName:(NSArray *)emailList{    
      if ( emailList != _emailList){
          [emailList retain]; // 保留新值
          [_emailList release]; // 释放旧值
          _emailList = emailList;
      }   
  }
</code></pre></li>
</ul>


<p>此setter将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要，假如两个值都指向对象A，还未保留新值就先把旧值释放了，那么先执行的release操作就可能导致对象A被回收，而后续的retain操作并无法令对象A复生，于是实例变量就成了悬挂指针</p>

<blockquote><p>当所指向的对象被释放或者收回，此情况下该指针便称悬垂指针（也叫迷途指针）。</p></blockquote>

<ul>
<li><p>copy  此语义与strong类似，不同在于setter并不保留新值，而是将其<code>copy</code>，如下：</p>

<pre><code>  @property (nonatomic, copy) NSString *name;

  -(void)setName:(NSString*)name{  
      if ( name != _name){  
          [_name release];
          _name = nil;
          _name = [name copy]; 
      }  
  }
</code></pre></li>
</ul>


<p>使用copy可以用来保护数据的封装性，比方说，传递过来的新值是一个NSMutableString的实例，此时若不<code>copy</code>，当设置完属性值之后，该可变新值在对象不知情的情况下遭人更改。所以，这时就要<code>copy</code>一份“不可变”(immutable)的字符串，确保对象中的字符串值不会不会无意间变动。</p>

<h3>ARC下内存管理 &mdash; 基本规则</h3>

<p>ARC下内存管理的一个基本规则：只要某个对象被任一strong指针指向，那么它将不会被回收。</p>

<h4>strong</h4>

<p>在MRC下，如果想令一个对象继续存活，需用retain来递增计数器，不过ARC已经在编译时帮我们加入了retain、release等，现在唯一需要的是，用一个强指针指向该对象，只要指针没有被空置，该对象会一直在堆上。</p>

<blockquote><p>实际上，不论MRC和ARC下，还是在用引用计数来管理内存，具体请看：<a href="http://limon-.github.io/blog/2015/01/13/nei-cun-guan-li-yin-yong-ji-shu-qi/">内存管理 - 引用计数器</a></p></blockquote>

<p>在默认情况下，所有的实例变量和局部变量都是strong类型的。可以说strong类型的指针在行为上和MRC时代的retain是比较相似的。</p>

<h4>weak</h4>

<p>weak常用在两个对象间存在包含关系时：对象A有一个strong指针指向对象B，并持有它，而对象B中也有一个weak指针指回对象B，从而避免了循环持有。</p>

<p>一个常见的例子就是delegate设计模式，viewController中有一个strong指针指向它所负责管理的UITableView，而UITableView中的dataSource和delegate指针都是指向viewController的weak指针。可以说，weak指针的行为和MRC时代的assign有一些相似点，但是考虑到weak指针更聪明些（会自动指向nil）</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/arcpic7.png" alt="" /></p>

<blockquote><p>代理模式可以简单认为，两个对象之间形成&#8221;半保留环&#8221;（A对象强指针指向B对象，B对象弱指针指向A对象）</p></blockquote>

<h3>ARC下内存管理 &mdash; 循环引用</h3>

<p>接下来简单讲讲容易循环引用的场景，详情请看<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW3">官方文档</a>的相关资料</p>

<h4>委托模式</h4>

<pre><code>@property (nonatomic,weak) id&lt;ComposeToolbarButtonTypeDelegate&gt; delegate; 
</code></pre>

<p>用<code>weak</code>形成“半保留环”，防止循环引用</p>

<h4>block</h4>

<p>这个网上大把，可以看看<a href="http://www.cnbluebox.com/?p=255">block使用小结、在arc中使用block、如何防止循环引用</a></p>

<h3>ARC下内存管理 &mdash; self</h3>

<p>ARC下，方法内的self既不是strong也不是weak，而是unsafe_unretained的（init系列方法的self除外）。
换而言之，在普通方法中，ARC不会对<code>self</code>做<code>retain</code>和<code>release</code>操作，生命周期全由调用方来决定，如果调用方没有保证<code>self</code>在被调用方法中的生命周期，可能在此方法中运行到一半，<code>self</code>就被释放了，可能程序就崩溃了。</p>

<h2>总结</h2>

<ul>
<li>ARC管理对象生命期的基本办法：在编译期间，在合适的地方插入<code>retain</code>和<code>release</code>操作</li>
<li>在ARC下，我们通常通过<code>内存管理语义</code>来管理内存，常见的有：<code>strong</code>、<code>weak</code>、<code>copy</code></li>
</ul>


<h2>番外</h2>

<p>研读了@sunny大大的<a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">《ARC对self的内存管理》</a>之后作一些笔记，</p>

<h2>参考资料</h2>

<p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">Objective-C Automatic Reference Counting (ARC)</a> &mdash;&ndash; 关于ARC的详细文档</p>

<p><a href="http://blog.sunnyxx.com/2015/01/17/self-in-arc/">ARC对self的内存管理</a> &mdash;&ndash; 专门对ARC下self的剖析</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理 - Autorelease]]></title>
    <link href="http://limon.top/autoreleasepool/"/>
    <updated>2015-01-19T16:12:34+08:00</updated>
    <id>http://limon.top/autoreleasepool</id>
    <content type="html"><![CDATA[<p>Autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用release，也就是计数器会减1，但是自动释放池被销毁了，里面的对象并不一定会被销毁。</p>

<p>简而言之，autorelease pool 避免了频繁申请/释放内存。</p>

<h2>pool什么时候被销毁？</h2>

<p>在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，此pool内的OC对象会被release。
那什么是一个Runloop呢？ 一个UI事件，Timer call， delegate call， 都会是一个新的Runloop</p>

<p>在Iphone项目中，大家会看到一个默认的Autorelease pool，程序开始时创建，程序退出时销毁，按照对Autorelease的理解，岂不是所有autorelease pool里的对象在程序退出时才release， 这样跟内存泄露有什么区别？</p>

<p>答案是，对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个栈式结构，遵循先进后出，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个OC对象会被release。</p>

<h2>pool嵌套，栈式结构</h2>

<p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个栈式结构，遵循先进后出</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>#import "Person.h" 
</span><span class='line'>int main(int argc, const char * argv[]) 
</span><span class='line'>{ 
</span><span class='line'>     
</span><span class='line'>    // 自动释放池1 
</span><span class='line'>    @autoreleasepool { 
</span><span class='line'>         
</span><span class='line'> // 对象的释放交给 自动释放池去管理 不用再写[person release] 
</span><span class='line'>        Person *person = [[Person alloc] init];  
</span><span class='line'>         
</span><span class='line'>        // 再创建一个自动释放池2 
</span><span class='line'>        @autoreleasepool { 
</span><span class='line'>             
</span><span class='line'>            Person *person2 = [[Person alloc] init]; 
</span><span class='line'>        } 
</span><span class='line'>        
</span><span class='line'>        Person *person3 = [[Person alloc] init];    
</span><span class='line'>    } 
</span><span class='line'>    return 0; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>pool2先被销毁，最后才是pool1，即释放顺序：person2 -> person3/person2</p>

<h3>#</h3>

<h4>一下内容整理于 #<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></h4>

<p>在ARC下，<code>@autoreleasepool{}</code>创建一个AutoreleasePool，随后编译器将其改写成下面的样子：</p>

<pre><code>void *context = objc_autoreleasePoolPush();
// {}中的代码
objc_autoreleasePoolPop(context);
</code></pre>

<p>而这两个函数都是对AutoreleasePoolPage的简单封装，所以自动释放机制的核心就在于这个类。</p>

<pre><code>class AutoreleasePoolPage 
{
    .....
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
    ....
}
</code></pre>

<ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>


<h2>总结</h2>

<ul>
<li>autorelease方法不会改变对象的引用计数器，只是将这个对象放到自动释放池中；</li>
<li>自动释放池实质是当自动释放池销毁后调用对象的release方法，不一定就能销毁对象（例如如果一个对象的引用计数器>1则此时就无法销毁）；</li>
<li>由于自动释放池最后统一销毁对象，因此如果一个操作比较占用内存（对象比较多或者对象占用资源比较多），最好不要放到自动释放池或者考虑放到多个自动释放池；</li>
<li>ObjC中类库中的静态方法一般都不需要手动释放，内部已经调用了autorelease方法；</li>
</ul>


<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>

<p><a href="http://www.cnblogs.com/kenshincui/p/3870325.html#autoreleasepool">Objective-C之内存管理</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理 - 引用计数]]></title>
    <link href="http://limon.top/nei-cun-guan-li-yin-yong-ji-shu-qi/"/>
    <updated>2015-01-13T14:27:14+08:00</updated>
    <id>http://limon.top/nei-cun-guan-li-yin-yong-ji-shu-qi</id>
    <content type="html"><![CDATA[<h2>内存管理概述</h2>

<p>在Objective-C中，系统并不会自动释放堆中的内存，其他高级语言C#、JAVA都有垃圾回收机制，但在Objective-C中并没有垃圾回收机制，那么Objective-C中的内存是如何管理？
Objective-C语言使用引用计数器来管理内存，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数器；用完之后，就递减其计数器；当计数器为0，就表示没人关注此对象，此对象就会被销毁。</p>

<h2>引用计数工作原理</h2>

<p>在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活。
NSObject协议声明了三个方法用于操作计数器</p>

<ul>
<li>Retain 递增计数器</li>
<li>Release 递减计数器</li>
<li>autorelease 待销毁autorelease pool时，再递减pool内的全部计数器</li>
</ul>


<p>1.对一个对象发送alloc、retain、new、copy消息，计数器 +1</p>

<p>2.对一个对象发送release消息，计数器 -1</p>

<p>3.当一个对象的引用计数器为0，对象就被回收(dealloced)，也就是说，系统会将对象其占用的内存标记为“可重用”(reuse)，放到“可用内存池”(avaiable pool)</p>

<h3>手动管理内存的三点原则</h3>

<ul>
<li>如果需要持有一个对象，那么对其发送retain</li>
<li>如果之后不再使用该对象，那么需要对其发送release（或者autorealse）</li>
<li>每一次对retain,alloc或者new的调用，需要对应一次release或autorealse调用</li>
</ul>


<h3>图表演示</h3>

<p>下图演示了一个对象自创建出来之后经历一次retain及两次release操作的过程</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/Memory.png" alt="Memory" /></p>

<p>下图所示的对象图中，ObjectB和ObjectC都引用了ObjectA，若B和C都不再使用A，则其计数器为0，便被回收。还有OrderObject想令B和C继续存活，而应用程序里又有另外的对象想令OrderObject继续存活，如果按“引用树“回溯，那么会发现一个“根对象”，在iOS中，则是UIApplication对象。此”根对象”是应用程序启动时创建的单例。</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/Memory-2.png" alt="Memory" /></p>

<h3>代码演示</h3>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    NSMutableArray *array = [[NSMutableArray alloc] init];
    NSNumber *number = [[NSNumber alloc] initWithInt:1337]; 

    [array addObject:number]; //number的引用计数器+1（此时number的引用计数器至少为2）
    [number release]; // -1

    // do something with `array’

    [array release];
    return YES;
}
</code></pre>

<blockquote><p>在调用数组的<code>-addObject</code>方法时，数组也会在number上调用retain，以期令此对象存活</p></blockquote>

<h2>引用计数的应用场景</h2>

<p>在上面的代码演示中，还不看出引用计数的真正用处。在函数内使用一个临时的对象，通常不需要修改引用计数，只需在返回前将该对象销毁即可。
引用计数真正的应用场景是，用于对象之间传递和共享数据。</p>

<h2>引用计数的注意要点</h2>

<h3>retainCount可能永远不为0</h3>

<p>可能有人会测试对象释放时，看retainCount是否为0，代码如下：</p>

<pre><code>NSObject *object = [[NSObject alloc] init];
NSLog(@"%lu",(unsigned long)[object retainCount]);
[object release];
NSLog(@"%lu",(unsigned long)[object retainCount]);
</code></pre>

<p>但是，打印的结果是 1  1</p>

<p>最后一次输出，引用计数并没有变成0，原因是在最后一次 release 时，系统马上就回收了内存，就没有再将retainCount减1，因为不将值从1变成0，可以减少一次内存操作，加快对象的回收，只有在系统不打算这么优化时，计数值才会递减为0</p>

<h3>悬挂指针</h3>

<p>当所指向的对象被释放或者收回，此情况下该指针便称悬垂指针（也叫迷途指针）。</p>

<blockquote><p>某些编程语言允许未初始化的指针的存在，而这类指针即为野指针。</p></blockquote>

<p>为什么对象被回收了，向其发送消息不会崩？代码如下：</p>

<pre><code>NSNumber *number = [[NSNumber alloc] initWithInt:1337];

[number release];

NSLog(@"number = %@",number);
</code></pre>

<p>内存已经被回收，如果向其发送消息，可能使程序崩溃。为什么说“可能”，而没说“一定”，是因为对象的所占的内存在“解除分配”(deallocated)之后，只是放回了“可用内存池”(avaiable pool)。如果在执行NSLog时尚未覆写对象内存，那么该对象仍然有效。</p>

<blockquote><p>由此可见，因过早释放对象而导致的bug很难调试</p></blockquote>

<p>为了防止此情况的发送，一般release之后都会清空指针</p>

<pre><code>NSNumber *number = [[NSNumber alloc] initWithInt:1337];

[number release];
number = nil; 
</code></pre>

<blockquote><p>在Objective-C中，向nil发送消息不会出错。</p></blockquote>

<h2>总结</h2>

<ul>
<li>Objective-C通过<code>引用计数机制</code>来管理内存</li>
<li>对象创建之后，其引用计数器至少为1，<code>retain</code>和<code>release</code>分别会递增及递减计数器</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬支付宝的各种坑]]></title>
    <link href="http://limon.top/pa-zhi-fu-bao-de-ge-chong-keng/"/>
    <updated>2015-01-07T13:57:57+08:00</updated>
    <id>http://limon.top/pa-zhi-fu-bao-de-ge-chong-keng</id>
    <content type="html"><![CDATA[<p>爬了几天坑，在笔者崩溃之际终于集成好了，在这里分享一下经验。</p>

<p>笔者用的是<code>支付宝移动支付SDK标准版(iOS 2.1.2)</code>，申请的手机快捷支付</p>

<h2>密钥</h2>

<p>利用支付宝给的<code>openssl.exe</code>工具生成一共三种密钥，私钥、公钥，PKCS8类型的私钥</p>

<ul>
<li>公钥：放在支付宝上，去掉首尾的<code>-----BEGIN PUBLIC KEY-----``-----END PUBLIC KEY-----</code></li>
<li>PKCS8类型的私钥：如果选择在手机端签名，此私钥放在<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
<li>私钥：此私钥带有<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>，是专门给PHP用的，即在服务器端(PHP)签名，需要用到此私钥

<blockquote><p>Note：推荐服务器端签名，不过需要注意的是，PHP端用的是带<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>的私钥。</p></blockquote></li>
</ul>


<h2>集成支付宝</h2>

<p>按照文档给的流程理论上想运行Demo是挺容易的，需要注意：</p>

<ul>
<li>Demo是在本地签的名，所以Demo上填写<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
</ul>


<p>如果认为看似Demo超简单，你就错了。</p>

<h3>坑一：Undefined symbols for architecture x86_64:</h3>

<p>笔者爬过的坑，<code>ssl库</code>不支持x86_64就是64位模拟器。（若在服务器端签名不需引入ssl库）</p>

<blockquote><p>程序界公认女神@念茜给出的答案。。。</p></blockquote>

<p>也就是以下这种错误</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/alipay.png" alt="alipay error" /></p>

<p>针对这个错误，笔者尝试了各种方法，Architectures的各种设置，甚至都是一行一行对着Demo来改的，还有C++ Flage等等，最终还是不行。</p>

<p>和客服聊了一个多小时，最后客服把支付宝最老的版本和13年的版本给笔者。。。。挺好人的。。。。</p>

<h3>坑二：rsaSign()和rsaVerify()</h3>

<p>作为一个技术渣，iOS我是搞不掂了，还是搞PHP吧。。。</p>

<p>吐血的是，笔者用支付宝给的PHP版Demo，用它里面的方法<code>rsaSign()</code>签名，然后再用<code>rsaVerify()</code>验签，结果<code>rsaVerify()</code>返回的结果永远都是false，后来笔者终于准备出坑了，醒悟这个<code>rsaVerify()</code>应该不是验证这签名的。</p>

<p>后来百度了解了点皮毛：</p>

<p>RSA非对称密钥</p>

<p>① 假设A、B机器进行通信，已A机器为主；</p>

<p>② A首先需要用自己的私钥为发送请求数据签名，并将公钥一同发送给B；</p>

<p>③ B收到数据后，需要用A发送的公钥进行验证，已确保收到的数据是未经篡改的；</p>

<p>④ B验签通过后，处理逻辑，并把处理结果返回，返回数据需要用A发送的公钥进行加密（公钥加密后，只能用配对的私钥解密）；</p>

<p>⑤ A收到B返回的数据，使用私钥解密，至此，一次数据交互完成。</p>

<blockquote><p><code>rsaVerify</code>笔者猜测是验证支付宝的回调的。换句话说，签名直接就用<code>rsaSign()</code>就好了，就以下这几行代码</p></blockquote>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>include('alipay_rsa.function.php');
</span><span class='line'>
</span><span class='line'>$data = $_POST['data'];
</span><span class='line'>$sign = rsaSign($data,'../key/rsa_private_key.pem');
</span><span class='line'>
</span><span class='line'>$arr = array(
</span><span class='line'>  'sign' =&gt; $sign
</span><span class='line'>);
</span><span class='line'>
</span><span class='line'>echo json_encode($arr);
</span><span class='line'>?&gt;</span></code></pre></td></tr></table></div></figure>


<p>以为这样就爬完了？</p>

<h3>坑三：urlEncoded</h3>

<p>想着服务器直接返回<code>sign</code>直接再拼接一下就提交给支付宝，结果又掉坑里。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic).....
</code></pre>

<p>又跑去和客服聊天，笔者问客服：服务器返回的<code>sign</code>应该还需要<code>urlEncoded</code>对吧，客服回我说：不用啊，服务器已经弄了啊。</p>

<pre><code>/**
* RSA签名
* @param $data 待签名数据
* @param $private_key_path 商户私钥文件路径
* return 签名结果
*/
function rsaSign($data, $private_key_path) {
    $priKey = file_get_contents($private_key_path);
    $res = openssl_pkey_get_private($priKey);
    openssl_sign($data, $sign, $res);
    openssl_free_key($res);
    //base64编码
    $sign = base64_encode($sign);
    return $sign;
}
</code></pre>

<p>客服说<code>base64_encode($sign)</code>完就可以了不需要<code>urlEncoded</code>。笔者果断还是不相信客服。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

// 深坑啊......    
signedString = [self urlEncodedString:signedString];

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic)....
</code></pre>

<p>需要在<code>RSADataSigner.m</code>中抽离<code>-urlEncodedString</code>方法出来。。。坑啊，明明都不需要手机端签名了，当然不会去看手机端签名的具体流程啦。又没看到哪里说明服务器端返回的<code>sign</code>需要<code>urlEncoded</code>，连客服都不知道需要<code>urlEncoded</code>&hellip;..</p>

<h3>心塞，不说了&hellip;&hellip;.</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa]]></title>
    <link href="http://limon.top/reactivecocoa/"/>
    <updated>2014-09-03T17:44:25+08:00</updated>
    <id>http://limon.top/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<h2>RACSignal</h2>

<h3>订阅RACSignal</h3>

<p>1.RACSignal (Subscription)
RACSignal (Subscription)类别可以看到所有的订阅事件的方法，每个方法都会将类型为(void (^)(id x))的block作为参数，当事件发生时block中的代码会执行，例如-subscribeNext:方法会传入一个block作为参数，当Signal的next事件发出后，block会接收到事件并执行。</p>

<p>2.UIKit Category
RAC为UIKit添加了很多类别来让我们可以订阅UI组件的事件，比如UITextField (RACSignalSupport)中的rac_textSignal会在文本域内容变化时发出next事件。
事件包含的内容可以是类型，只要是对象就行，如果是一些数字，布尔值等字面量，可以用@()语法装箱成NSNumber。</p>

<h3>操纵Signal</h3>

<h5>1.RACStream (Operations)</h5>

<p><code>-filter</code>:uses a block to test each value. Returns a new stream with only those values that passed.</p>

<pre><code>- (instancetype)filter:(BOOL (^)(id value))block;
    RACSequence *numbers = [@"1 2 3 4 5 6 7 8 9" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: 2 4 6 8
RACSequence *filtered = [numbers filter:^ BOOL (NSString *value) {
    return (value.intValue % 2) == 0;
}];
</code></pre>

<p><code>-map</code>:Maps block across in the receiver , and transform the values. Returns a new stream with the mapped values.</p>

<pre><code>- (instancetype)map:(id (^)(id value))block;
    RACSequence *letters = [@"A B C D E F G H I" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: AA BB CC DD EE FF GG HH II
RACSequence *mapped = [letters map:^(NSString *value) {
    return [value stringByAppendingString:value];
}];
</code></pre>

<p><code>-flattenMap</code>:Maps block across the values in the receiver and flattens the result. It is used to signal of signal.简单理解为：取出内部的Signal.</p>

<pre><code>[[[self.signInButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
        map:^id(id x) {
            return [self signInSignal]; // 此signal内含一个BOOL signal
    }]
    subscribeNext:^(id x) {
        NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>打印出来的不是BOOL，<code>-subscribeNex</code>t: will execute the block whenever the signal sends a value. 但这value不包括 signal of signals：an outer signal that contains an inner signal.</p>

<pre><code>2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result: 
                        &lt;RACDynamicSignal: 0xa068a00&gt; name:+createSignal:
</code></pre>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>[[[self.signInButton
</span><span class='line'>   rac_signalForControlEvents:UIControlEventTouchUpInside]
</span><span class='line'>   flattenMap:^id(id x) { // subscribe to the inner signal within the outer signal’s
</span><span class='line'>     return [self signInSignal];
</span><span class='line'>   }]
</span><span class='line'>   // Output: Sign in result: 0
</span><span class='line'>   subscribeNext:^(id x) {
</span><span class='line'>     NSLog(@"Sign in result: %@", x);
</span><span class='line'>   }];</span></code></pre></td></tr></table></div></figure>


<h4>2.RACSignal (Operations)</h4>

<h2>RACObserve</h2>

<pre><code>// When self.username changes, logs the new name to the console.
//
// RACObserve(self, username) creates a new RACSignal that sends the current
// value of self.username, then the new value whenever it changes.
// -subscribeNext: will execute the block whenever the signal sends a value.
[RACObserve(self, username) subscribeNext:^(NSString *newName) {
    NSLog(@"%@", newName);
}];
</code></pre>

<h4>过滤signal</h4>

<pre><code>// Only logs names that starts with "j".
//
// -filter returns a new RACSignal that only sends a new value when its block
// returns YES.
[[RACObserve(self, username)
    filter:^(NSString *newName) {
        return [newName hasPrefix:@"j"];
    }]
    subscribeNext:^(NSString *newName) {
        NSLog(@"%@", newName);
}];
</code></pre>

<h2>Chip</h2>

<p><code>distinctUntilChanged</code>：Returns a stream of values for which -isEqual: returns NO when compared to the previous value.
用来确保signal只会发送不同的值,比较数值流中当前值和上一个值，如果不同，就返回当前值，简单理解,它将这一次的值与上一次做比较，当相同时（也包括- isEqual:）被忽略掉。</p>

<pre><code>RACSignal *validSearchSignal =
[[RACObserve(self, searchText)
  map:^id(NSString *text) {
     return @(text.length &gt; 3);
  }]
  distinctUntilChanged]; // ensure this signal only emits values when the state changes.

[validSearchSignal subscribeNext:^(id x) {
    NSLog(@"search text is valid %@", x);
}];

self.executeSearch =
[[RACCommand alloc] initWithEnabled:validSearchSignal // validSearchSignal决定button能不能点击
  signalBlock:^RACSignal *(id input) {
    return  [self executeSearchSignal];
  }];
</code></pre>

<p>例子二：比如UI上一个Label绑定了一个值，根据值更新显示的内容:</p>

<pre><code>RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];
self.user.username = @"sunnyxx"; // 1st
self.user.username = @"sunnyxx"; // 2nd
self.user.username = @"sunnyxx"; // 3rd 
</code></pre>

<p>所以，对于相同值可以忽略的情况，果断加上它吧。</p>

<p><code>-takeUntilBlock</code>：对于每个next值，运行block，当block返回YES时停止取值，如：</p>

<pre><code>[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) {
    return [value isEqualToString:@"stop"];
}] subscribeNext:^(NSString *value) {
    NSLog(@"current value is not `stop`: %@", value);
}];
</code></pre>

<blockquote><p>Note：停止取值的意思是，输入stop之后，无论输入什么都不会再取值，即输入stop之后，不会再有任何输出。
还有一个例子：</p></blockquote>

<pre><code>- (RACSignal*) rac_RequestStateSignal
{
    return [[RACObserve(self, state)
        takeUntilBlock:^ BOOL (NSNumber *state){
            return [state intValue] == iRequestStateComplete;
        }]
        flattenMap:^(NSNumber *state){
            if ([state intValue] == iRequestStateErrored)
            { 
                // Create a meaningful NSError here if you can.
                return [RACSignal error:nil];
            }
            else
            { 
                return [RACSignal return:state];
            }
        }];
}
</code></pre>

<p><code>-switchToLatest</code>方法用于signal-of-signals，它总是输出最新的信号的值。</p>

<pre><code>RACSubject *letters = [RACSubject subject];
RACSubject *numbers = [RACSubject subject];
RACSubject *signalOfSignals = [RACSubject subject];

RACSignal *switched = [signalOfSignals switchToLatest];

// Outputs: A B 1 D
[switched subscribeNext:^(NSString *x) {
    NSLog(@"%@", x);
}];

[signalOfSignals sendNext:letters]; // 打印letters信号内的值
[letters sendNext:@"A"];
[letters sendNext:@"B"];

[signalOfSignals sendNext:numbers]; // 打印numbers信号内的值
[letters sendNext:@"C"];
[numbers sendNext:@"1"];

[signalOfSignals sendNext:letters]; // 打印letters信号内的值
[numbers sendNext:@"2"];
[letters sendNext:@"D"];
</code></pre>

<p><code>-rac_signalForSelector:fromProtocol:</code></p>

<p>这个方法主要是把 protocal 转为一个 Signal 便于使用。值得注意的是这个函数返回的是一个 RACTuple。 这个 RACTuple 包含了 Selector 方法里面所有的参数</p>

<p><code>-rac_liftSelector:withSignalsFromArray:</code>
这个方法它的意思是当传入的 Signals 都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容。就会去触发第一个 selector 参数的方法。</p>

<blockquote><p><a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">ReactiveCocoa 用 RACSignal 替代 Delegate</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa的三种基本的模式]]></title>
    <link href="http://limon.top/reactivecocoa/"/>
    <updated>2014-06-10T09:35:03+08:00</updated>
    <id>http://limon.top/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<hr />

<h3>三种基本的模式</h3>

<p>在ReactiveCocoa中有三种基本的模式：责任链、分割和组合模式（chaining, splitting, and combining）。</p>

<h4>一、 Chaining模式</h4>

<p>Chaining，将一个已有的signal转换为一个新的signal。常用的操作是创建一个新的signal，再对它使用filter:、map:或startWith:等方法。</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.textField.text) = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}]; 
</span></code></pre></td></tr></table></div></figure>


<p>我们将textFiled的text属性绑定为三个串连的signals的结果。首先，我们创建一个间隔信号，这个信号每隔一秒钟就发送当前时间。间隔信号在没有启动的时候是不会有值的，所以我们使用startWith:启动起来。最后，使用map:将signal的NSDate值转换为一个NSString字符串，这个字符串将会被赋值到textField的text属性上。
<img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/chaining.png" alt="Chaining" /></p>

<p> Chaining是最常用的操作，而且它通常不使用局部变量，而是像上面那样串连起来操作。下面的代码与上面的代码是等同的。</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *intervalSignal = [RACSignal interval:1];  
</span><span class='line'>RACSignal *startedIntervalSignal = [intervalSignal startWith:[NSDate date]];  
</span><span class='line'>RACSignal *mappedIntervalSignal = [startedIntervalSignal map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.textField.text) = mappedIntervalSignal;  </span></code></pre></td></tr></table></div></figure>


<h4>二、Splitting模式</h4>

<p>Splitting与chaining比较类似，也是将signal转换为其它的sginal，不同之处在于，Splitting会重复使用signal。Splitting看起来要复杂些，其实也就是一个signal使用多次。</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *dateComponentsSignal = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>    return dateComponents;  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.minuteTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.minute];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.secondTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.second];  
</span><span class='line'>}];  </span></code></pre></td></tr></table></div></figure>


<p>在上面这个例子中，创建了一个signal，即局部变量：dateComponentsSignal。接着再用dateComponentsSignal创建两个新的signal，并将它们分别与两个textfield的text属性进行绑定。</p>

<blockquote><p>Note: 把dateComponentsSignal看作一个局部变量，就像,int a = 9; 然后多次使用a来计算。</p></blockquote>

<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/Splitting.png" alt="Splitting" /></p>

<h4>三、Combining模式</h4>

<p>combining就是将几个signal结合起来创建出一个新的signal。比如“登录”按钮，只有在“用户名”与“密码”输入框中的文本长度都超过6时才能被点击，否则处于不可用的状态。那么我们可以为“登录”按钮的enabled状态创建一个signal，这个signal则是由“用户名”与“密码”框它们两个自己的signal组合起来：</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.submitButton.enabled) = [RACSignal combineLatest:@[self.usernameField.rac_textSignal, self.passwordField.rac_textSignal] reduce:^id(NSString *userName, NSString *password) {  
</span><span class='line'>    return @(userName.length &gt;= 6 && password.length &gt;= 6);  
</span><span class='line'>}]; </span></code></pre></td></tr></table></div></figure>


<p>在这里，我们将“登录”按钮的enable状态绑定到使用combineLatest:reduce:方法创建的signal上。这个方法的第二个参数是一个block，这个block的参数是combineLatest中的参数的<strong>最新值</strong>的组合。我们将两个文本框的text signal一起传到combineLatest，在reduce的block中，该block也就会接收到两个NSString的参数，这个block的工作就是将两个参数值组合起来生成一个值，然后返回。该方法的说明：</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>// +combineLatest:reduce: takes an array of signals, executes the block with the
</span><span class='line'>// latest value from each signal whenever any of them changes, and returns a new
</span><span class='line'>// RACSignal that sends the return value of that block as values.</span></code></pre></td></tr></table></div></figure>


<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/combining.png" alt="Combining" /></p>

<p>Combining常用于两种情况：</p>

<ol>
<li>需要同时满足多种条件。</li>
<li>在多个signal中进行选择。</li>
</ol>


<h2>优秀文章</h2>

<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/">Getting Started with ReactiveCocoa</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#01-字面量语法]]></title>
    <link href="http://limon.top/number-01-zi-mian-liang-yu-fa/"/>
    <updated>2014-05-26T12:40:19+08:00</updated>
    <id>http://limon.top/number-01-zi-mian-liang-yu-fa</id>
    <content type="html"><![CDATA[<h2>字面量数值</h2>

<p>普通创建：</p>

<pre><code>NSNumber *num = [NSNumber numberWithInt:1];
</code></pre>

<p>字面量创建</p>

<pre><code>NSNumber *nub = @1;

int a = 5;
float b = 5.32f;
NSNumber *num = @(a * b);
</code></pre>

<h2>字面量数组</h2>

<p>普通创建</p>

<pre><code>NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",@"Apple",nil];
[fruits objectAtIndex:1]; // Apple
</code></pre>

<p>字面量创建</p>

<pre><code>NSArray *fruits = @[@"Lemon",@"Apple"];
fruits[1]; // Apple
</code></pre>

<p><code>fruits[1]</code>这称为取下标操作(subscripting)</p>

<h2>nil</h2>

<p>字面量创建数组，若数组元素对象中有nil，会抛出异常。因为字面量语法实际上是一种语法糖(syntactic sugar)，其效果等于是先创建了一个数组，然后把方括号内的所有对象都加到这个数组。</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = @[@"Lemon",nilObject,@"Apple"]; // 崩了
</code></pre>

<p>如果不用字面量创建，用<code>NSArray arrayWithObjects:</code>则不会抛出异常，只会提前结束。如下例子，遇到nil结束，fruits只有一个元素</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",nilObject,@"Apple",nil];
</code></pre>

<blockquote><p>微妙的差别表明，使用字面量语法更安全。向数组插入nil通常说明程序有错，而通过异常可以更快地发现这个错误。</p></blockquote>

<h2>字面量字典</h2>

<p>值 -> 键：普通创建</p>

<pre><code>NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:@"Tom",@"name",[NSNumber numberWithInt:18],@"age", nil];
[personData objectForKey:@"name"]; // Tom
</code></pre>

<p>键 -> 值：字面量语法创建</p>

<pre><code>NSDictionary *personData = @{@"name": @"Tom",@"age":@18};
personData[@"age"]; // 18
</code></pre>

<h2>可变数组和字典</h2>

<p>如果数组与字典对象是可变的(mutable)，也可以通过下标修改可变数组或字典的值</p>

<pre><code>mutableArray[1] = @"dog";
mutableDictionary[@"name"] = @"Mary";
</code></pre>

<p>普通做法：</p>

<pre><code>[mutableArray replaceObjectAtIndex:1 withObject:@"dog"];
[mutableDic setObject:@"Mary" forKey:@"name"];
</code></pre>

<h2>局限</h2>

<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable),若想可变版本的对象，则需要赋值一份</p>

<pre><code>NSMutableDictionary *mutableDic = [@{@"name": @"Tom",@"age":@18} mutableCopy];
</code></pre>

<h2>要点</h2>

<ul>
<li>应该使用字面量语法创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，更加简明扼要。</li>
<li>应该通过下标来访问数组和字典</li>
<li>用字面量语法创建数组或字典时，若值中有nil，会抛出异常。</li>
</ul>


<h2>番外</h2>

<p>JSON格式，一对 <code>{ }</code> 代表一个字典，一对<code>[]</code>代表一个数组</p>

<pre><code>{
    "result": 1,

    "school_list": [
        {
            "id": "5",
            "school_name": "清华大学"             
        },
        {
            "id": "6",
            "school_name": "北京邮电大学"
        }
    ],

    "school_near": "北京交通大学"
}
</code></pre>

<p>从JSON<strong>字典</strong>中通过键<code>school_list</code>取出数组对象</p>

<pre><code>NSArray *arr = json[@"school_list"];
NSArray *arr = [json objectForKey:@"school_list"];
</code></pre>

<p>arr数组的元素是一个个字典，遍历数组得到字典内的学校名</p>

<pre><code>for( int i=0; i&lt;arr.count; i++){
        NSString *schoolName = arr[i][@"school_name"];
        NSString *schoolName = [[arr objectAtIndex:i] objectForKey:@"school_name"];
    }
</code></pre>

<p>其实arr数组就是PHP内的二维数组，只不过在OS中，</p>

<ul>
<li>数组 - 下标为数字（PHP中的索引数组）</li>
<li>字典 - 下标为字符串（PHP中的关联数组）</li>
</ul>


<p>上面例子中二维数组arr的遍历，通过数字下标遍历二维数组中的所有元素，然后通过字符串下标取出学校名。</p>

<blockquote><p>下标也称为键</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转Mantle]]></title>
    <link href="http://limon.top/mantlede-shi-yong/"/>
    <updated>2014-04-23T10:05:15+08:00</updated>
    <id>http://limon.top/mantlede-shi-yong</id>
    <content type="html"><![CDATA[<h2>MTLModel</h2>

<p>MTLModel provides an easy way to map NSDictionary objects to Objective-C classes and vice-versa.</p>

<p>假设返回的JSON为：</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'> {
</span><span class='line'>  "uid": 1,
</span><span class='line'>  "title": "Found a bug",
</span><span class='line'>  "url": "https://api.github.com/repos/octocat/Hello-World/issues/1347",
</span><span class='line'>  "number": 1347,
</span><span class='line'>  "state": "open",
</span><span class='line'>  "user": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1
</span><span class='line'>  },
</span><span class='line'>  "assignee": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1,
</span><span class='line'>    "type": "User"
</span><span class='line'>  }
</span><span class='line'>  "created_at": "2011-04-22T13:33:48Z",
</span><span class='line'>  "awesome": true  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>继承<code>MTLModel</code>遵守<code>&lt;MTLJSONSerializing&gt;</code>协议</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Mantle.h&gt;
</span><span class='line'>
</span><span class='line'>typedef enum : NSUInteger {
</span><span class='line'>    GHIssueStateOpen,
</span><span class='line'>    GHIssueStateClosed
</span><span class='line'>} GHIssueState;
</span><span class='line'>
</span><span class='line'>@interface GHIssue : MTLModel&lt;MTLJSONSerializing&gt;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *uid;
</span><span class='line'>@property (nonatomic, copy, readonly) NSURL *URL;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *number;
</span><span class='line'>@property (nonatomic, assign, readonly) GHIssueState state;
</span><span class='line'>@property (nonatomic, copy, readonly) NSString *reporterLogin;
</span><span class='line'>@property (nonatomic, copy, readonly) NSDate *updatedAt;
</span><span class='line'>@property (nonatomic, strong, readonly) GHUser *assignee;
</span><span class='line'>@property(nonatomic, getter=isAwesome) BOOL awesome;
</span><span class='line'>@property (nonatomic, copy) NSString *title;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p><code>&lt;MTLJSONSerializing&gt;</code>协议告诉Mantle序列化该对象如何从JSON映射到Objective-C的属性。</p>

<h3>NSValueTransformer</h3>

<p>在.m文件，实现<code>&lt;MTLJSONSerializing&gt;</code>的协议<code>@required</code>的方法<code>+ (NSDictionary *)JSONKeyPathsByPropertyKey</code>
它指明了如何把json的keypath和Model的属性对应起来</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSDictionary *)JSONKeyPathsByPropertyKey {
</span><span class='line'>  // properties defined in header  :  key in JSON Dictionary，本地字段在前，服务端字段在后
</span><span class='line'>    return @{
</span><span class='line'>        @"URL": @"url",
</span><span class='line'>        @"HTMLURL": @"html_url",
</span><span class='line'>        @"reporterLogin": @"user.login",
</span><span class='line'>        @"assignee": @"assignee",
</span><span class='line'>        @"updatedAt": @"updated_at"
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为如果属性名和JSON的键名一致时，可以省略不写映射，例如title</p>

<p>以上分了几种情况：
Mantle使用主要看属性property中的类型，主要分几种：</p>

<ol>
<li>NSNumber、NSString&hellip;.</li>
<li>NSArray</li>
<li>NSURL</li>
<li>NSDate</li>
<li>枚举</li>
<li>模型</li>
<li>BOOL</li>
</ol>


<p>先介绍一个方法：<code>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key</code></p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>// Specifies how to convert a JSON value to the given property key. If
</span><span class='line'>// reversible, the transformer will also be used to convert the property value
</span><span class='line'>// back to JSON.
</span><span class='line'>//
</span><span class='line'>// If the receiver implements a `+&lt;key&gt;JSONTransformer` method, MTLJSONAdapter
</span><span class='line'>// will use the result of that method instead.
</span><span class='line'>//
</span><span class='line'>// Returns a value transformer, or nil if no transformation should be performed.
</span><span class='line'>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;
</span></code></pre></td></tr></table></div></figure>


<p>以下方法的命名都要遵从：<code>SEL selector = MTLSelectorWithKeyPattern(key, "JSONTransformer");</code></p>

<p>1、一般像tittle，<code>@"title": @"title"</code>不用写这行也自动转化。我个人认为从服务器返回的所有数据都是字符串类型。所有理论上，uid还要用<code>NSValueTransformer</code>转化，如下：</p>

<pre><code>+ (NSValueTransformer *)uidJSONTransformer{
    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^id(NSString *string) {
    return @([string integerValue]);
} reverseBlock:^id(NSNumber *number) {
    return [number stringValue];
}];
</code></pre>

<p>}</p>

<p>但是，如果你的uid属性类型定义为NSNumber，还是不需用上面的方法，应该是Mantle自己处理了。</p>

<blockquote><p>如果你定义的uid类型为NSUInteger，还是需要uidJSONTransformer</p></blockquote>

<p>还有一种情况是<code>@"reporterLogin": @"user.login"</code>
   login是在JSON内层的元素，需要用下面这个方法</p>

<pre><code class="```">   + (NSValueTransformer *)reporterLoginJSONTransformer {
        return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSArray *values) {
            return [values firstObject];
        } reverseBlock:^(NSString *str) {
            return @[str];
        }];
    }
</code></pre>

<p>2、NSArray装模型</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  name: "Bob",
</span><span class='line'>  cars: [
</span><span class='line'>    { make: "ford", year: "1972" },
</span><span class='line'>    { make: "mazda", year: "2000" }
</span><span class='line'>  ],
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>@interface CarModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *make;
</span><span class='line'>@property (nonatomic, strong) NSString *year;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@interface PersonModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *name;
</span><span class='line'>@property (nonatomic, strong) NSArray *cars; // NSArra元素是Car模型
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)carsJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CarModel.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3、NSURL</p>

<pre><code>+ (NSValueTransformer *)URLJSONTransformer {
    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
}           
</code></pre>

<p>4、NSDate</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>+ (NSDateFormatter *)dateFormatter {
</span><span class='line'>    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
</span><span class='line'>    dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
</span><span class='line'>    dateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss'Z'";
</span><span class='line'>    return dateFormatter;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (NSValueTransformer *)updatedAtJSONTransformer { // 把"updated_at": "2011-04-22T13:33:48Z"传给ForwardBlock
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [self.dateFormatter dateFromString:str]; // 把dateFormatter再传给reverseBlock
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [self.dateFormatter stringFromDate:date];
</span><span class='line'>    }]
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果JSON的数据格式是Unix时间戳，&#8221;date&#8221;: 1418202490,</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)dateJSONTransformer {
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [NSDate dateWithTimeIntervalSince1970:str.floatValue];
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [NSString stringWithFormat:@"%f",[date timeIntervalSince1970]];
</span><span class='line'>    }];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>5、枚举</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)stateJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{
</span><span class='line'>        @"open": @(GHIssueStateOpen),
</span><span class='line'>        @"closed": @(GHIssueStateClosed)
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>6、模型</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)assigneeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONDictionaryTransformerWithModelClass:GHUser.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>7、 BOOL</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)awesomeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>空对象处理</h2>

<p>在模型.m文件添加<code>-setNilValueForKey</code>，Mantle是基于KVC给property赋值的，KVC提供了<code>-setNilValueForKey</code>方法，让我们为nil指定一个合理的替代值</p>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>@interface MTLModel (KTVNullableScalar)
</span><span class='line'>@end
</span><span class='line'>@implementation MTLModel (KTVNullableScalar)
</span><span class='line'>- (void)setNilValueForKey:(NSString *)key {
</span><span class='line'>    [self setValue:@0 forKey:key];  // For NSInteger/CGFloat/BOOL
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>Create model objects from JSON</h2>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from JSON data
</span><span class='line'>NSData JSONData = ... // the JSON response from the API
</span><span class='line'>NSError *error = nil;
</span><span class='line'>NSDictionary *JSONDict = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:&error];
</span><span class='line'>
</span><span class='line'>// create model object from NSDictionary using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = [MTLJSONAdapter modelOfClass:CATProfile.class fromJSONDictionary:JSONDict error:NULL];</span></code></pre></td></tr></table></div></figure>


<h2>Create JSON from model objects</h2>

<figure class='code'><div class="highlight"><table style="margin-top: 5px; margin-left: -15px;"><tr><td class="gutter"><pre></pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from model class using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = ...
</span><span class='line'>NSDictionary *profileDict = [MTLJSONAdapter JSONDictionaryFromModel:profile];
</span><span class='line'>NSError *error = nil;
</span><span class='line'>// convert NSDictionary to JSON data
</span><span class='line'>NSData *JSONData = [NSJSONSerialization dataWithJSONObject:profileDict options:0 error:&error];</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Note：如果不想JSONData含有模型的某个属性，可以在模型JSONKeyPathsByPropertyKey方法中
    return @{ @&ldquo;Name&rdquo;: NSNull.null };</p></blockquote>

<h2>Serialize 序列化</h2>

<p>待续&hellip;</p>

<h2>优秀文章</h2>

<p><a href="http://spin.atomicobject.com/2014/06/23/ios-models-mantle/">Simplify iOS Models With Mantle – An Intro</a></p>

<p><a href="http://www.objc.at/mantle">mantle</a></p>

<p><a href="http://www.cnblogs.com/ipinka/p/4041835.html">iOS的Mantle实战</a></p>

<p><a href="http://ke.gitcafe.io/2014/10/13/Why-Changba-iOS-choose-Mantle/">为什么唱吧iOS 6.0选择了Mantle</a></p>
]]></content>
  </entry>
  
</feed>
